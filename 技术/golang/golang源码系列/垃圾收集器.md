#垃圾回收 #golang

# 垃圾回收的基本想法
Go 实现的垃圾回收器是无分代（对象没有代际之分）、 不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。 从宏观的角度来看，Go 运行时的垃圾回收器主要包含五个阶段：
![[Pasted image 20220225171938.png]]

对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。 但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。 Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。

在这五个阶段中，只有标记、内存清扫和内存归还三个阶段的写屏障状态是保持不变的。 在清扫终止过程中，写屏障先出于关闭状态， 而后对上个垃圾回收阶段进行一些收尾工作（例如清理缓存池、停止调度器等等）， 然后才被启动；在标记终止阶段，写屏障先出于启动状态，完成标记阶段的收尾工作后， 写屏障被关闭，并随后对整个 GC 阶段进行的各项数据进行统计等等收尾工作。 而在实际实现过程中，垃圾回收器通过 `_GCoff`、`_GCMark` 和 `_GCMarktermination` 三个标记来确定写屏障状态，这时写屏障的启动状态严格的在 `_GCoff` 到 `_GCMark` 到 `_GCMarktermination` 再到 `_GCoff` 的切换中进行变化。

分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收）， 而非频繁检查所有对象。但 Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收）， 只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。 也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上， 当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。 并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。 Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收）， 而非减少停顿时间这一单一目标上。

# Go语言中的垃圾回收
## 为什么不选择压缩GC
压缩算法的主要优势是减少碎片并且快速分配。Go语言使用了现代内存分配算法TCmalloc，虽然没有压缩算法那样极致，但它已经很好地解决了内存碎片的问题。并且，由于需要加锁，压缩算法并不适合在并发程序中使用。另外，在Go语言设计初期，由于时间紧迫，设计团队放弃了考虑更加复杂的压缩算法，转而使用了更简单的三色标记算法

## 为什么不选择分代GC
Go语言并不是没有尝试过分代GC。分代GC的主要假设是大部分变成垃圾的对象都是新创建的，但是由于编译器的优化，Go语言通过内存逃逸的机制将会继续使用的对象转移到了堆中，大部分生命周期很短的对象会在栈中分配，这和其他使用分代GC的编程语言有显著的不同，减弱了使用分代GC的优势。同时，分代GC需要额外的写屏障来保护并发垃圾回收时对象的隔代性，会减慢GC的速度。因此，分代GC是被尝试过并抛弃的方案


## 三色并发标记法
前面提到的“标记”类算法都有一个共同的瑕疵，即在进行垃圾回收的时候会暂停整个程序（`STW`问题）。三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。`GC`线程将所有对象分为三类：

-   白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象
-   灰色：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描
-   黑色：已搜索完的对象，所有的引用已经被扫描完

在go内部对象并没有保存颜色的属性, 三色只是对它们的状态的描述,  
白色的对象在它所在的span的gcmarkBits中对应的bit为0,  
灰色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象在标记队列中,  
黑色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象已经从标记队列中取出并处理.  
gc完成后, gcmarkBits会移动到allocBits然后重新分配一个全部为0的bitmap, 这样黑色的对象就变为了白色.

三色标记法属于增量式`GC`算法，回收器首先将所有的对象着色成白色，然后从`GC Root`出发，逐步把所有“可达”的对象变成灰色再到黑色，最终所有的白色对象即是“不可达”对象。

具体的实现如下：
-   初始时所有对象都是白色对象
-   从`GC Root`对象出发，扫描所有可达对象并标记为灰色，放入待处理队列
-   从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列
-   重复上一步骤，直到灰色对象队列为空
-   此时所有剩下的白色对象就是垃圾对象

优点：
-   不需要暂停整个程序进行垃圾回收

缺点：

-   如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集
-   线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量

我们先来看看Golang的三色标记法的大体流程。

首先：程序创建的对象都标记为白色。

![](https://i6448038.github.io/img/gc/mark_sweep_5.png)

gc开始：扫描所有可到达的对象，标记为灰色

![](https://i6448038.github.io/img/gc/mark_sweep_6.png)

从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色

![](https://i6448038.github.io/img/gc/mark_sweep_7.png)

监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在

![](https://i6448038.github.io/img/gc/mark_sweep_8.png)

此时，gc回收白色对象。

![](https://i6448038.github.io/img/gc/mark_sweep_9.png)

最后，将所有黑色对象变为白色，并重复以上所有过程。

![](https://i6448038.github.io/img/gc/mark_sweep_10.png)

好了，大体的流程就是这样的，让我们回到刚才的问题：Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？

## gc和用户逻辑如何并行操作？

标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

Go如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。  
我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：`清除操作和用户逻辑可以并发。`

标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？

### process新生成对象的时候，GC该如何操作呢？不会乱吗？

我们看如下图，在此状态下：process程序又新生成了一个对象，我们设想会变成这样：

![](https://i6448038.github.io/img/gc/mark_sweep_11.png)

但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象A最后会被清除掉，这样会影响程序逻辑。

Golang为了解决这个问题，引入了`写屏障`这个机制。  
写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。  
通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)

在上述情况中，`新生成的对象，一律都标位灰色！`  
即下图：

![](https://i6448038.github.io/img/gc/mark_sweep_12.png)

### 那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？

看如下图，一个黑色对象引用了曾经标记的白色对象。

![](https://i6448038.github.io/img/gc/mark_sweep_13.png)

这时候，写屏障机制被触发，向GC发送信号，GC重新扫描对象并标位灰色。

![](https://i6448038.github.io/img/gc/mark_sweep_14.png)

因此，gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。
## 读写屏障技术
> 屏障技术：给代码操作内存的顺序添加一些限制，即在内存屏障前执行的动作必须先于在你内存屏障后执行的动作。

使用屏障技术可以使得用户程序和三色标记过程并发执行，我们只需要达成下列任意一种三色不变性：

-   强三色不变性：黑色对象永远不会指向白色对象
-   弱三色不变性：黑色对象指向的白色对象至少包含一条由灰色对象经过白色对象的可达路径

`GC`中使用的内存读写屏障技术指的是编译器会在编译期间生成一段代码，该代码在运行期间用户读取、创建或更新对象指针时会拦截内存读写操作，相当于一个`hook`调用，根据`hook`时机不同可分为不同的屏障技术。由于读屏障`Read barrier`技术需要在读操作中插入代码片段从而影响用户程序性能，所以一般使用写屏障技术来保证三色标记的稳健性。

> 我们讲内存屏障技术解决了三色标记法的`STW`缺点，并不是指消除了所有的赋值器挂起问题。需要分清楚`STW`方法是全局性的赋值器挂起而内存屏障技术是局部的赋值器挂起。

![[Pasted image 20220225164214.png]]
垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。 作为内存屏障的一种，写屏障（Write Barrier）是一个在并发垃圾回收器中才会出现的概念。

可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性 [Wilson, 1992]：

-   条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象；
-   条件 2: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

-   如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
-   如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。
我们不妨将三色不变性所定义的波面根据这两个条件进行削弱：

-   当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为强三色不变性（strong tricolor invariant）
-   当赋值器令黑色对象引用白色对象时（满足条件 1 时）的情况称为弱三色不变性（weak tricolor invariant）

当赋值器进一步破坏灰色对象到达白色对象的路径时（进一步满足条件 2 时），即打破弱三色不变性， 也就破坏了回收器的正确性；或者说，在破坏强弱三色不变性时必须引入额外的辅助操作。 弱三色不变形的好处在于：**只要存在未访问的能够到达白色对象的路径，就可以将黑色对象指向白色对象。**


### **4. Dijkstra插入写屏障**

`Dijkstra`插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象。

```text
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1) 将新下游对象标记为灰色
    shade(ptr)
    // 2) 当前下游对象slot = 新下游对象ptr
    *slot = ptr
}
​
// 场景一：A之前没有下游, 新添加一个下游对象B, B被标记为灰色
A.DijkstraWritePointer(nil, B)
// 场景二：A将下游对象C更换为B, B被标记为灰色
A.DijkstraWritePointer(C, B)
```

一个对象可以存储在内存中的“栈”或者“堆”，由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间。在“插入写屏障”保护下的三色标记法执行例子如下：

![](https://pic4.zhimg.com/80/v2-db934ce574068f536cf8eff8780ec647_720w.jpg)

![](https://pic3.zhimg.com/80/v2-281449398ec60396d8005aa1b8acb03a_720w.jpg)

![](https://pic4.zhimg.com/80/v2-c90b6b812eb39f28270cdbc0b44a7253_720w.jpg)

-   第一步：垃圾回收之前将所有的对象标记为白色
-   第二步：遍历`GC Root Set`，将可达对象标记为灰色
-   第三步：遍历灰色对象列表，将可达的对象从白色标记为灰色；将遍历完的灰色对象标记为黑色
-   第四步：在三色标记过程中用户程序令栈区对象A指向对象H，令堆区对象E指向对象I，由于对象E在`堆区从而触发插入写屏障并将黑色对象E指向的白色对象I标记为灰色，栈区对象A不触发
-   第五步：继续三色标记直至灰色对象队列为空
-   第六步：由于栈区对象没有启动插入写屏障，因此栈上可能存在白色对象被引用的情况（上图中对应对象H），因此在回收白色对象前在`STW`保护下重新扫描一次栈空间
-   第七步：在`STW`保护下对栈空间一次性进行三色标记，直到灰色对象队列为空
-   第八步：结束`STW`
-   第九步：最后将栈空间和堆空间的白色垃圾对象进行回收

尽管`Dijkstra`插入写屏障可以实现垃圾回收和用户程序的并发执行，但是它存在两个缺点。一方面它是一种比较保守的垃圾回收方法，把有可能存活的对象都标记成灰色了以满足“强三色不变性”。以下图为例，用户程序`Mutator`将对象A原本指向B对象的指针改成指向C对象，尽管在修改后B对象已经是一个垃圾对象，但是它在本轮垃圾回收过程中不会被回收。

![](https://pic1.zhimg.com/80/v2-170a91bca3fbba0e25911a07756af1c8_720w.jpg)

另外一个缺点在于栈上的对象也是根对象，`Dijkstra`插入写屏障要么在用户程序执行内存写操作时为栈上对象插入写屏障，要么在一轮三色标记完成后使用`STW`重新对栈上的对象进行三色标记。前者会降低栈空间的响应速度，后者会暂停用户程序。
Dijkstra 屏障的优势在于：

1.  性能优势：它不需要对指针进行任何处理，因为指针的读操作通常比写操作高出一个或更多数量级。
2.  前进保障：与 Steele 写屏障不同，对象可从白色到灰色单调转换为黑色，因此总工作量受到堆大小的限制。

Dijkstra 写屏障的缺点在于对性能的权衡：

但存在两个缺点：

-   由于 Dijkstra 插入屏障的保守，在一次回收过程中可能会产生一部分被染黑的垃圾对象，只有在下一个回收过程中才会被回收；
-   在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销，为了避免造成性能问题，可以选择关闭栈上的指针写操作的 Dijkstra 屏障。当发生栈上的写操作时，将栈标记为恒灰（permagrey）的，但此举产生了灰色赋值器，将会需要标记终止阶段 STW 时对这些栈进行重新扫描。

### **5. Yuasa删除写屏障**

`Yuasa`删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径。当用户程序执行`*slot = ptr`时（即令`slot`指向了`ptr`），我们会将当前下游对象`*slot`标记为灰色。一句话解释就是当删除对象`A`指向对象`B`的指针时，那么将被删除的对象标记为灰色。

```text
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1) 将当前下游对象标记为灰色
    shade(*slot)
    // 2) 当前下游对象slot = 新下游对象ptr
    *slot = ptr
}
​
// 场景一：B被A删除, 将B标记为灰色
A.添加下游对象(B, nil)
// 场景二：B被A删除, 将B标记为灰色
A.添加下游对象(B, C)
```

![](https://pic4.zhimg.com/80/v2-dcf8032f4580902e21774feb0aaf751b_720w.jpg)

-   第一步：将所有对象标记为白色
-   第二步：遍历`GC Root Set`将可达对象设为灰色
-   第三步：如果用户程序令灰色对象`A`删除了对白色对象`D`的引用，如果这时候不触发删除写屏障，那么对象`D`、`B`和`C`直到本轮垃圾回收结束都会是白色对象。因此需要触发删除写屏障，将对象`D`标记为灰色。
-   第四步：遍历灰色对象队列，将可达的白色对象标记为灰色，遍历完的灰色对象标记为黑色
-   第五步：继续进行三色标记，直到灰色对象队列为空
-   第六步：清除所有的白色对象

下图简单绘制了`Yuasa`删除写屏障是如何保证用户程序`Mutator`和垃圾回收器`Collector`的并发执行的：

-   第二步中`Mutator`将对象`A`原本指向对象`B`的指针指向`C`，由于对象`B`本身就是灰色的，因此不需要对它重新着色
-   第三步中`Mutator`删除了对象`B`指向对象`C`的指针，删除写屏障将下游对象`C`标记为灰色

![](https://pic4.zhimg.com/80/v2-58bac6eb968dacdeb15151a6c224286b_720w.jpg)

`Yuasa`删除写屏障和`Dijkstra`插入写屏障相比优点在于不需要在一轮三色标记后对栈空间上的对象进行重新扫描，缺点在于`Collector`会悲观地认为所有被删除的对象都可能被黑色对象引用，比如上图中第三步`Mutator`删除了对象`B`指向对象`C`的指针，那么本该被删除的对象`E`却可以在本轮垃圾回收中存活。

### **6. 混合写屏障**

### **6.1 引入混合写屏障的原因**

在`go v1.8`引入混合写屏障`hybrid write barrier`之前，由于`GC Root`对象包括了栈对象，如果运行时在所有`GC Root`对象上开启插入写屏障意味着需要在数量庞大的`Goroutine`的栈上都开启`Dijkstra`写屏障从而严重影响用户程序的性能。之前的做法是`Mark`阶段（`golang`垃圾回收使用的是标记-清除法）结束后暂停整个程序，对栈上对象重新进行三色标记法。

> 如果`Goroutine`较多的话，对栈对象`re-scan`这一步需要耗费`10~100 ms`。

回顾一下之前提到的两种写屏障的劣势：

-   `Dijkstra`插入写屏障：一轮标记结束后需要`STW`重新扫描栈上对象
-   `Yuasa`删除写屏障：回收精度低，在垃圾回收开始前使用`STW`扫描所有`GC Root`对象形成初始快照，用户程序`Mutator`从灰色/白色对象中删除白色指针时会将下游对象标记为灰色，相当于保护了所有初始快照中的白色对象不被删除
### **6.2 混合写屏障的实现**

```text
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1) 将被删除的下游对象标记为灰色
    shade(*slot)
    // 2) 将新下游对象标记为灰色
    shade(ptr)
    // 3) 当前下游对象slot = 新下游对象ptr
    *slot = ptr
}
```

> 注意：混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率

混合写屏障逻辑如下：

-   `GC`开始时将栈上所有对象标记为黑色，无须`STW`
-   `GC`期间在栈上创建的新对象均标记为黑色
-   将被删除的下游对象标记为灰色
-   将被添加的下游对象标记为灰色

### **6.3 具体场景的实现**

`GC`开始阶段会将所有栈空间可达对象都标记为黑色：

  

![](https://pic1.zhimg.com/80/v2-35789021d1eb8572ddf8ebf8d35875f0_720w.jpg)

场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收
![](https://pic2.zhimg.com/80/v2-bf66067eb24bdd1306267194a6d14395_720w.jpg)

场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。

![](https://pic4.zhimg.com/80/v2-85835762eacfb2267ca4eab132061b7f_720w.jpg)

场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象`G`被错误回收，我们需要将其标记为灰色

![](https://pic2.zhimg.com/80/v2-33d5d4e718f09bae4889109f8d815115_720w.jpg)
场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象`G`需要标记成灰色以保护它和它的下游对象不被错误删除

![](https://pic4.zhimg.com/80/v2-a87f234312af61ccb642170745b06493_720w.jpg)

## Golang GC如何扫描对象
Golang扫描对象可以分为三部分：

-   编译阶段：对静态类型做好标记准备
-   运行阶段：赋值器分配内存时，根据编译阶段的type为对象内存对应的指针设置bitmap
-   扫描阶段：根据指针的bitmap进行扫描

## Golang GC实现
`go v1.5`至今都是基于三色标记法实现的垃圾回收机制，从而将长时间的`STW`分隔成多段较短时间的`STW`，`Golang`将垃圾回收阶段分成三个状态：

-   `GC`开始前将所有对象标记为白色
-   将`GC Root`对象（`golang`中是**栈对象**和**全局变量**的指针）加入灰色对象队列
-   使用并发的`goroutine`扫描队列中的指针，如果指针还引用了其他指针，那么将被引用的加入灰色对象队列，被扫描的对象标记为黑色

### **3.1 Golang GC四个阶段**

前面提到Golang的GC属于并发式垃圾回收（意味着不需要长时间的STW，GC大部分执行过程是和用户代码并行的），它可以分为四个阶段：
1.  清理终止阶段；
    1.  **暂停程序**，所有的处理器在这时会进入安全点（Safe point）；
    2.  如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2.  标记阶段；
    1.  将状态切换至 `_GCmark`、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
    2.  恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
    3.  开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
    4.  依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
    5.  使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3.  标记终止阶段；
    1.  **暂停程序**、将状态切换至 `_GCmarktermination` 并关闭辅助标记的用户程序；
    2.  清理处理器上的线程缓存；
4.  清理阶段；
    1.  将状态切换至 `_GCoff` 开始清理阶段，初始化清理状态并关闭写屏障；
    2.  恢复用户程序，所有新创建的对象会标记成白色；
    3.  后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；
运行时虽然只会使用 `_GCoff`、`_GCmark` 和 `_GCmarktermination` 三个状态表示垃圾收集的全部阶段，但是在实现上却复杂很多，本节将按照垃圾收集的不同阶段详细分析其实现原理。

> 在GC过程中会有两种后台任务（G），包括标记任务和清扫任务。可以同时执行的标记任务约是P数量的四分之一，即go所说的25%CPU用于GC的依据。清扫任务会在程序启动后运行，进入清扫阶段时唤醒。

### **3.2 辅助GC**

由于Golang使用了并发式的垃圾回收，将原本需要STW较长时间的GC过程分散到多次小规模的GC。当用户分配内存的速度超过GC回收速度时，Golang会通过辅助GC暂停用户程序进行垃圾回收，防止内存因分配对象速度过快消耗殆尽的问题。

### **3.3 GC触发时机**

触发垃圾回收首先要满足三个前提条件：

-   `memstats.enablegc`：允许垃圾回收
-   `panicking == 0`：程序没有panic
-   `gcphase == _GCoff`：处于`_Gcoff`阶段

对应的触发时机包括：
-   gcTriggerAlways: 强制触发GC
-   `gcTriggerHeap`：堆内存的大小达到一定阈值
-   `gcTriggerTime`：距离上一次垃圾回收超过一定阈值时
-   `gcTriggerCycle`：如果当前没有启动GC则开始新一轮的GC

```go
// test reports whether the trigger condition is satisfied, meaning
// that the exit condition for the _GCoff phase has been met. The exit
// condition should be tested when allocating.
func (t gcTrigger) test() bool {
    if !memstats.enablegc || panicking != 0 || gcphase != _GCoff {
        return false
    }
    switch t.kind {
    case gcTriggerHeap://堆内存的分配到达控制器计算的触发堆大小
        // Non-atomic access to heap_live for performance. If
        // we are going to trigger on this, this thread just
        // atomically wrote heap_live anyway and we'll see our
        // own write.
        return memstats.heap_live >= memstats.gc_trigger
    case gcTriggerTime:
        if gcpercent < 0 {
            return false
        }
        lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
        //如果一定时间内没有触发，就会触发新的循环
        return lastgc != 0 && t.now-lastgc > forcegcperiod
    case gcTriggerCycle:
	    //要求启动新一轮的GC，已启动就跳过
        // t.n > work.cycles, but accounting for wraparound.
        return int32(t.n-work.cycles) > 0
    }
    return true
}
```

下次 GC 的时机可以通过一个环境变量 GOGC 来控制，默认是 100 ，即增长 100% 的堆内存才会触发 GC。

> This value represents a ratio of how much new heap memory can be allocated before the next collection has to start.

官方的解释是，如果当前使用了 4M 内存，那么下次 GC 将会在内存达到 8M 的时候。
gcTriggerTime 的触发时间是由 forcegcperiod 决定的，默认是2分钟。下面我们主要看看堆内存大小触发 GC 的情况。

gcTriggerHeap 堆内存的分配达到达控制器计算的触发堆大小，heap_live 值会在内存分配的时候进行计算，gc_trigger 的计算是在 `runtime.gcSetTriggerRatio`函数中进行的。

```go
func gcSetTriggerRatio(triggerRatio float64) { 
 // gcpercent 由环境变量 GOGC 决定
 if gcpercent >= 0 {
  // 默认是 1
  scalingFactor := float64(gcpercent) / 100 
  // 最大的 maxTriggerRatio 是 0.95
  maxTriggerRatio := 0.95 * scalingFactor
  if triggerRatio > maxTriggerRatio {
   triggerRatio = maxTriggerRatio
  }

  // 最大的 minTriggerRatio 是 0.6
  minTriggerRatio := 0.6 * scalingFactor
  if triggerRatio < minTriggerRatio {
   triggerRatio = minTriggerRatio
  }
 } else if triggerRatio < 0 { 
  triggerRatio = 0
 }
 memstats.triggerRatio = triggerRatio

 trigger := ^uint64(0)
 if gcpercent >= 0 {
        // 当前标记存活的大小乘以1+系数triggerRatio
  trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))
  ...
 }
 memstats.gc_trigger = trigger
 ...
}
```

gcSetTriggerRatio 函数会根据计算出来的 triggerRatio 来获取下次触发 GC 的堆大小是多少。triggerRatio 每次GC后都会调整，计算 triggerRatio 的函数是 `gcControllerState.endCycle`中进行的，`gcControllerState.endCycle` 会在 MarkDone 中被调用的。

```go
func (c *gcControllerState) endCycle() float64 {
 const triggerGain = 0.5
 // 目标Heap增长率 = （下次 GC 完后堆大小 - 堆存活大小）/ 堆存活大小
 //目标Heap增长率，默认是1.0
 goalGrowthRatio := float64(memstats.next_gc-memstats.heap_marked) / float64(memstats.heap_marked)
 // 实际Heap增长率, 等于总大小/存活大小-1
 actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
 // GC标记阶段的使用时间（因为endCycle是在Mark Termination阶段调用的）
 assistDuration := nanotime() - c.markStartTime
 // GC标记阶段的CPU占用率, 目标值是0.25
 utilization := gcBackgroundUtilization
 // Add assist utilization; avoid divide by zero.
 if assistDuration > 0 {
  // assistTime 是G辅助GC标记对象所使用的时间合计
  // 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 * P的数量)// 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 * P的数量)
  utilization += float64(c.assistTime) / float64(assistDuration*int64(gomaxprocs))
 }
 // 触发系数偏移值 = 目标增长率 - 原触发系数 - CPU占用率 / 目标CPU占用率 * (实际增长率 - 原触发系数)
 // 参数的分析: 
 // 实际增长率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早 
 // CPU占用率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早 
 // 原触发系数越大, 触发系数偏移值越小, 小于0时下次触发GC会提早
 triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-memstats.triggerRatio)

 // 根据偏移值调整触发系数, 每次只调整偏移值的一半
 triggerRatio := memstats.triggerRatio + triggerGain*triggerError
 
 return triggerRatio
}
```

对于 triggerRatio 总体来说还是比较复杂的，我们可以根据偏离值来得知：

-   实际增长率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早；
-   CPU占用率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早；
-   原触发系数越大, 触发系数偏移值越小, 小于0时下次触发GC会提早；

通过上面的分析，也解释了为什么在 `GODEBUG=gctrace=1`分析中明明堆内存还没达到 2倍却被提前执行了，主要还是受 triggerError 偏移量的影响导致的。
公式中的"目标Heap增长率"可以通过设置环境变量"GOGC"调整, 默认值是100, 增加它的值可以减少GC的触发.  
设置"GOGC=off"可以彻底关掉GC.

gcTriggerTime的判断代码如下:

```go
lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
return lastgc != 0 && t.now-lastgc > forcegcperiod
```

forcegcperiod的定义是2分钟, 也就是2分钟内没有执行过GC就会强制触发.

### **4. GC调优常见方法**

-   尽量使用小数据类型，比如使用`int8`代替`int`。
-   少使用`+`连接`string`：go语言中string是一个只读类型，针对string的每一个操作都会创建一个新的string。大量小文本拼接时优先使用`strings.Join`，大量大文本拼接时使用`bytes.Buffer`。


# 垃圾回收循环
Go语言的垃圾回收循环大致会经历如图20-1所示的几个阶段。当内存到达了垃圾回收的阈值后，将触发新一轮的垃圾回收。之后会先后经历标记准备阶段、并行标记阶段、标记终止阶段及垃圾清扫阶段。在并行标记阶段引入了辅助标记技术，在垃圾清扫阶段还引入了辅助清扫、系统驻留内存清除技术。
![[Pasted image 20220225104513.png]]

## 标记准备阶段
标记准备阶段最重要的任务是清扫上一阶段GC遗留的需要清扫的对象，因为使用了懒清扫算法，所以当执行下一次GC时，可能还有垃圾对象没有被清扫。同时，标记准备阶段会重置各种状态和统计指标、启动专门用于标记的协程、统计需要扫描的任务数量、开启写屏障、启动标记协程等。总之，标记准备阶段是初始阶段，执行轻量级的任务。在标记准备阶段，上面大部分重要的步骤需要在STW（Stop The World）时进行。关于写屏障、清扫与懒清扫将在后面的小节中介绍。
标记准备阶段会为每个逻辑处理器P启动一个标记协程，但并不是所有的标记协程都有执行的机会，因为在标记阶段，标记协程与正常执行用户代码的协程需要并行，以减少GC给用户程序带来的影响。在这里，需要关注标记准备阶段两个重要的问题——如何决定需要多少标记协程以及如何调度标记协程。
### 计算标记协程的数量
在标记准备阶段，会计算当前后台需要开启多少标记协程。目前，Go语言规定后台标记协程消耗的CPU应该接近25%
如果有四个P，那么就是有一个单独的P用于执行标记任务，假如有两个P，2 * 0.25=0.5，就是只能花0.5个P来执行标记任务。它表示在总的标记周期t内，每个P都需要花25%的时间来执行后台标记工作。这是一种基于时间的调度。当超出时间后，当前的后台标记协程可以被抢占，从而执行其他的协程。
### 切换到后台标记进程
标记准备阶段的第2个问题是如何调度标记协程。在标记准备阶段执行了STW，此时暂停了所有协程。可以预料到，当关闭STW准备再次启动所有协程时，每个逻辑处理器P都会进入一轮新的调度循环（详见第17章），在调度循环开始时，调度器会判断程序是否处于GC阶段，如果是，则尝试判断当前P是否需要执行后台标记任务

## 并发标记阶段
在并发标记阶段，后台标记协程可以与执行用户代码的协程并行。Go语言的目标是后台标记协程占用CPU的时间为25%，以最大限度地避免因执行GC而中断或减慢用户协程的执行。如图20-4所示，后台标记任务有3种不同的模式。
DedicatedMode代表处理器专门负责标记对象，不会被调度器抢占。
FractionalMode代表协助后台标记，在标记阶段到达目标时间后，会自动退出。
IdleMode代表当处理器没有查找到可以执行的协程时，执行垃圾收集的标记任务，直到被抢占。标记阶段的核心逻辑位于gcDrain函数，其中第2个参数为后台标记flag，大部分flag和后台标记协程3种不同的模式有关。
### 根对象扫描
扫描的第一阶段是扫描根对象。在最开始的***标记准备阶段***会统计这次GC一共要扫描多少对象，每个具体的序号都对应着要扫描的对象
那么何为根对象呢？根对象是最基本的对象，从根对象出发，可以找到所有的引用对象（即活着的对象）。在Go语言中，根对象包括全局变量（在.bss和.data段内存中）、span中finalizer的任务数量，以及所有的协程栈。finalizer是Go语言中对象绑定的析构器，当对象的内存释放后，需要调用析构器函数，从而完整释放资源。例如，os.File对象使用析构器函数关闭操作系统文件描述符，即便用户忘记了调用close方法也会释放操作系统资源。
#### 根对象

在GC的标记阶段首先需要标记的就是"根对象", 从根对象开始可到达的所有对象都会被认为是存活的.  
根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.  
扫描根对象包含了一系列的工作, 它们定义在[[https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54)]函数:

-   Fixed Roots: 特殊的扫描工作
    -   fixedRootFinalizers: 扫描析构器队列
    -   fixedRootFreeGStacks: 释放已中止的G的栈
-   Flush Cache Roots: 释放mcache中的所有span, 要求STW
-   Data Roots: 扫描可读写的全局变量
-   BSS Roots: 扫描只读的全局变量
-   Span Roots: 扫描各个span中特殊对象(析构器列表)
-   Stack Roots: 扫描各个G的栈

标记阶段(Mark)会做其中的"Fixed Roots", "Data Roots", "BSS Roots", "Span Roots", "Stack Roots".  
完成标记阶段(Mark Termination)会做其中的"Fixed Roots", "Flush Cache Roots".

#### 标记队列

GC的标记阶段会使用"标记队列"来确定所有可从根对象到达的对象都已标记, 上面提到的"灰色"的对象就是在标记队列中的对象.  
举例来说, 如果当前有[A, B, C]这三个根对象, 那么扫描根对象时就会把它们放到标记队列:

```text
work queue: [A, B, C]
```

后台标记任务从标记队列中取出A, 如果A引用了D, 则把D放入标记队列:

```text
work queue: [B, C, D]
```

后台标记任务从标记队列取出B, 如果B也引用了D, 这时因为D在gcmarkBits中对应的bit已经是1所以会跳过:

```text
work queue: [C, D]
```

如果并行运行的go代码分配了一个对象E, 对象E会被立刻标记, 但不会进入标记队列(因为确定E没有引用其他对象).  
然后并行运行的go代码把对象F设置给对象E的成员, 写屏障会标记对象F然后把对象F加到运行队列:

```text
work queue: [C, D, F]
```

后台标记任务从标记队列取出C, 如果C没有引用其他对象, 则不需要处理:

```text
work queue: [D, F]
```

后台标记任务从标记队列取出D, 如果D引用了X, 则把X放入标记队列:

```text
work queue: [F, X]
```

后台标记任务从标记队列取出F, 如果F没有引用其他对象, 则不需要处理.  
后台标记任务从标记队列取出X, 如果X没有引用其他对象, 则不需要处理.  
最后标记队列为空, 标记完成, 存活的对象有[A, B, C, D, E, F, X].

实际的状况会比上面介绍的状况稍微复杂一点.  
标记队列会分为全局标记队列和各个P的本地标记队列, 这点和协程中的运行队列相似.  
并且标记队列为空以后, 还需要停止整个世界并禁止写屏障, 然后再次检查是否为空.

### 全局变量扫描
扫描全局变量需要编译时与运行时的共同努力。只有在运行时才能确定全局变量被分配到虚拟内存的哪一个区域，另外，如果全局变量有指针，那么在运行时其指针指向的内存可能变化。而在编译时，可以确定全局变量中哪些位置包含指针，如图20-7所示，信息位于位图ptrmask字段中。ptrmask的每个bit位都对应了.data段中一个指针的大小（8byte），bit位为1代表当前位置是一个指针，这时，需要求出当前的指针在堆区的哪一个对象上，并将当前对象标记为灰色。
有些读者可能觉得不可思议，如何通过指针找到指针对应的对象位置呢？这靠的是Go语言对内存的精细化管理。如图20-8所示，可以先找到指针在哪一个heapArena中，heapArena是内存分配时每一次向操作系统申请的最小64MB的区域。
![[Pasted image 20220225110617.png]]
heapArena存储了许多元数据，其中包括每个page（8 KB）对应的mspan。
所以，可以进一步通过指针的位置找到其对应的mspan，进而找到其位于mspan中第几个元素中。当找到此元素后，会将gcmarkBits位图对应元素的bit设置为1，表明其已经被标记，同时将该元素（对象）放入标记队列中。在span中，位图gcmarkBits中的每个元素都有标志位表明当前元素中的对象是否被标记，如图20-9所示。
![[Pasted image 20220225110700.png]]
### finalizer
之前提到finalizer是特殊的对象，其是在对象释放后会被调用的析构器，用于资源释放。析构器不会被栈上或全局变量引用，需要单独处理。
如下所示，在标记期间，后台标记协程会遍历mspan中的specials链表，扫描finalizer所位于的元素（对象），并扫描当前元素（对象），扫描对象的详细过程将在下一节介绍。注意在这里，并不能把finalizer所位于的span中的对象加入根对象中，否则我们将失去回收该对象的机会。同时需要扫描析构器字段fn，因为fn可能指向了堆中的内存，并可能被回收。
使用finalizer可以实现一些有趣的功能，例如Go语言的文件描述符使用了finalizer，这样在文件描述符不再被使用时，即便用户忘记了手动关闭文件描述符，在垃圾回收时也可以自动调用finalizer关闭文件描述符。另外，finalizer可以将资源的释放托管给垃圾回收，这一点在一些高级的场景（例如CGO）中非常有用。在Go语言调用C函数时，C函数分配的内存不受Go垃圾回收的管理，这时我们常常借助defer在函数调用结束时手动释放内存。如下所示，在defer释放C结构体中的指针。
![[Pasted image 20220225111443.png]]
将其修改为finalizer的形式如下，其中runtime.KeepAlive保证了finalizer的调用只能发生在该函数之后。另外，finalizer函数并不一定要执行实际的内存释放，可以将当前指针存储起来，由单独的协程定时释放。
![[Pasted image 20220225111456.png]]
### 栈扫描
栈扫描是根对象扫描中最重要的部分，因为在一个程序中，可能有成千上万个协程栈。栈扫描需要编译时与运行时的共同努力，运行时能够计算出当前协程栈的所有栈帧信息，而编译时能够得知栈上有哪些指针，以及对象中的哪一部分包含了指针。运行时首先计算出栈帧布局，每个栈帧都代表一个函数，运行时可以得知当前栈帧的函数参数、函数本地变量、寄存器SP、BP等一系列信息。

每个栈帧函数的参数和局部变量，都需要进行扫描，确认该对象是否仍然在使用，如果在使用则需要扫描位图判断对象中是否包含指针。
什么情况下对象可能没有被使用呢？如下所示，当foo函数执行到调用bar函数时，局部对象t就已经没有被使用了，所以即便对象中有指针，位图中仍然全为0，因为一个不再被使用的对象，不需要再被扫描。
![[Pasted image 20220225111751.png]]
### 栈对象
Go语言早期就是通过上述方式对协程栈中的对象进行扫描的。但是这种方法在有些情况下会出现问题，例如在如下函数中，对象t首先被变量p引用，但是在之后的程序中，变量p的值发生了变化，这意味着对象t其实并没有被使用。但是由于编译器难以知道变量p在何时会重新赋值导致对象t不再被引用，因此会采取保守的算法认为对象t仍然存在，此时如果对象t中有指针指向了堆内存，就会造成内存泄漏，因为这部分内存本应该被释放。
![[Pasted image 20220225112057.png]]
为了解决内存泄漏问题，Go语言引进了栈对象（stack object）的概念[1]。栈对象是在栈上能够被寻址的对象。例如上例中的对象t，由于其能够被&t的形式寻址，所以其一定在栈上有地址，这样的对象t就被叫作栈对象。不是所有的变量都会存储在栈上，例如存储在寄存器中的变量就是不能被寻址的。
编译器会在编译时将所有的栈对象都记录下来，同时，编译器将追踪栈中所有可能指向栈对象的指针。在垃圾回收期间，所有的栈对象都会存储到一棵二叉搜索树中。

如图20-10所示，假设F为一个局部变量指针，其引用了栈帧上的栈对象E→C→D→A，那么说明栈对象E、C、D、A都是存活的，需要被扫描。相反，如果栈对象B没有被引用，并且接下来在foo函数中没有使用到B对象，那么B对象将不会被扫描，从而解决了内存泄漏问题。
![[Pasted image 20220225112256.png]]

### 扫描灰色对象
从根对象的收集来看，全局变量、析构器、所有协程的栈都会被扫描，从而标记目前还在使用的内存对象。下一步是从这些被标记为灰色的内存对象出发，进一步标记整个堆内存中活着的对象。
如图20-11所示，在进行根对象扫描时，会将标记的对象放入本地队列中，如果本地队列放不下，则放入全局队列中。这种设计最大限度地避免了使用锁，在本地缓存的队列可以被逻辑处理器P无锁访问。
![[Pasted image 20220225113628.png]]
在进行扫描时，使用相同的原理，先消费本地队列中找到的标记对象，如果本地队列为空，则加锁获取全局队列中存储的对象。
在标记期间、会循环往复地从本地标记队列获取灰色对象，灰色对象扫描到的白色对象仍然会被放入标记队列中，如果扫描到已经被标记的对象则忽略，一直到队列中的任务为空为止。
对象的扫描过程位于scanobject函数中。之前介绍过，堆上的任意一个指针都能找到其对象所在span中的位置，并且可以通过gcmarkBits位图检查对象是否被扫描。但现在面对的问题是需要对所有对象的内存逐个进行扫描，查看对象内存中是否含有指针，如果对象中没有存储指针，则根本不需要花时间进行检查。为了实现更快的查找，Go语言在内存分配时记录了对象中是否包含指针等元信息。
（-----这块的描述在go语言底层原理这书中有详细描述）

## 标记终止阶段
完成并发标记阶段所有灰色对象的扫描和标记后进入标记终止阶段，标记终止阶段主要完成一些指标，例如统计用时、统计强制开始GC的次数、更新下一次触发GC需要达到的堆目标、关闭写屏障等，并唤醒后台清扫的协程，开始下一阶段的清扫工作。标记终止阶段会再次进入STW。
标记终止阶段的重要任务是计算下一次触发GC时需要达到的堆目标，这叫作垃圾回收的调步算法。调步算法是Go 1.5提出的算法，由于从Go 1.5开始使用并发的三色标记，在GC开始到结束的过程中，用户协程可能被分配了大量的内存，所以在GC的过程中，程序占用的内存（后简称占用内存）的大小实际上超过了我们设定的触发GC的目标。为了解决这样的问题，需要对程序进行估计，从而在达到内存占用量目标（后简称目标内存）之前就启动GC，并保证在GC结束之后，占用内存的大小刚好在目标内存附近，如图20-14所示。
![[Pasted image 20220225114558.png]]
因此，调步算法最重要的任务是估计出下一次触发GC的最佳时机，而这依赖本次GC的阶段差额——GC完成后占用内存与目标内存之间的差距。如果GC完成后占用内存远小于目标内存，则意味着触发GC的时间过早。如果GC完成后占用内存远大于目标内存，则意味着触发GC的时间太迟。因此调度算法的第1个目标是min（|目标占用内存-GC完成后的占用内存|）。除此之外，调步算法还有第2个目标，即预计执行标记的CPU占用率接近25%。结合之前提到的25%的后台标记协程，这个要求是满足的，在正常情况下，只有25%的CPU会执行后台标记任务。但如果用户工作协程执行了辅助标记（将在下节介绍），那么这一前提将不再成立。如果用户协程执行了过多的辅助标记，则会导致GC完成后的占用内存偏小，因为用户协程将本来应该用来分配内存的时间用来了执行辅助标记。算法将先计算目标内存与GC完成后的占用内存的偏差，
![[Pasted image 20220225115232.png]]
![[Pasted image 20220225115319.png]]
从公式中可以看出，实际增长率和辅助标记的时长都会影响最终的偏差率。目标内存与GC完成后的占用内存偏离越大偏差率越大。这是，下一次GC的触发率会渐进调整，即每次只调整偏离的一半，公式如下：
	下次GC触发率=上次GC触发率+1/2×偏差率
计算出下次GC触发率后，需要计算出目标内存大小，这是在标记终止阶段的gcSetTriggerRatio函数中完成的
![[Pasted image 20220225120225.png]]
goal为下次GC完成后的目标内存，其大小取决于本次GC扫描后的占用内存及gcpercent的大小。gcpercent可以由用户动态设置，调用标准库的SetGCPercent函数，可以修改gcpercent的大小。

gcpercent的默认值为100，代表目标内存是上一次GC目标内存的2倍。当gcpercent的值小于0时，将禁用Go的垃圾回收。另外，也可以通过在编译或运行时添加GOGC环境变量的方式修改gcpercent的大小，其核心逻辑是在程序初始化时调用readgogc函数实现的。例如，GOGC=off./main将关闭GC。
明确了目标内存后，触发内存的大小可以简单定义如下：
		触发内存=触发率×目标内存，
其中，触发率不能大于0.95，也不能小于0.6。

目前触发 GC 的条件使用的是从 Go 1.5 时提出的**调步（Pacing）算法**， 调步算法是优化并发执行时 GC 的步调，换句话说就是解决什么时候应该触发下一次 GC 的这个问题。

调步算法包含四个部分：

1.  GC 周期所需的扫描估计器
2.  为用户代码根据堆分配到目标堆大小的时间估计扫描工作量的机制
3.  用户代码为未充分利用 CPU 预算时进行后台扫描的调度程序
4.  GC 触发比率的控制器

现在我们从两个不同的视角来对这个问题进行建模。


## 辅助标记
Go 1.5引入了并发标记后，带来了许多新的问题。例如，在并发标记阶段，扫描内存的同时用户协程也不断被分配内存，当用户协程的内存分配速度快到后台标记协程来不及扫描时，GC标记阶段将永远不会结束，从而无法完成完整的GC周期，造成内存泄漏。
为了解决这样的问题，引入辅助标记算法。辅助标记必须在垃圾回收的标记阶段进行，由于用户协程被分配了超过限度的内存而不得不将其暂停并切换到辅助标记工作。所以一个简单的策略是让X=M，其中，X为后台标记协程需要多扫描的内存，M为新分配的内存。即在并发标记期间，一旦新分配了内存M，就必须完成M的扫描工作。我们之前看到过，对于obj这样的对象，并不需要扫描对象中所有的内存。

因此扫描策略可以调整为X=assistWorkPerByte×M
其中，assistWorkPerByte < 1，代表每字节需要完成多少扫描工作，并且真实需要扫描的内存会少于实际的内存。
在GC并发标记阶段，当用户协程分配内存时，会先检查是否已经完成了指定的扫描工作。当前协程中的gcAssistBytes字段代表当前协程可以被分配的内存大小，类似资产池。当本地的资产池不足时（即gcAssistBytes<0），会尝试从全局的资产池中获取。用户协程一开始是没有资产的，所有的资产都来自后台标记协程。
从图20-15中可以看出全局资产池与本地资产池的协调过程，用户协程中的本地资产来自后台标记协程的扫描工作。后台标记协程的扫描工作会增加全局资产池的大小。之前提到，X=assistWorkPerByte×M。反过来，如果标记协程已经扫描完成的内存为X，那么意味着全局资产池可以容忍用户协程分配的内存数量为M=X/assistWorkPerByte。这种机制保证了在GC并发标记时，工作协程分配的内存数量不至于过多，也不会太少。
![[Pasted image 20220225120959.png]]
如果工作协程在分配内存时，既无法从本地资产池也无法从全局资产池获取资产，那么需要停止工作协程，并执行辅助标记协程。辅助标记协程需要额外扫描的内存大小为assistWorkPerByte×M，当扫描完成指定工作或被抢占时会退出。当辅助标记完成后，如果本地仍然没有足够的资产，则可能是因为当前协程被抢占，也可能是因为当前逻辑处理器的工作池中没有多余的标记工作。当协程被抢占时，会调用Gosched函数让渡当前辅助标记的执行权利，而如果当前逻辑处理器的工作池中没有多余的标记工作可做，则会陷入休眠状态，当后台标记协程扫描了足够的任务后，会刷新全局资产池并将等待中的协程唤醒，如图20-16所示。
![[Pasted image 20220225121058.png]]
## 屏障技术
在并发标记中，标记协程与用户协程共同工作的模式带来了很多难题。如果说辅助标记解决的是垃圾回收正常结束与循环的问题，那么屏障技术将解决更棘手的问题——准确性。如图20-17所示，假设在垃圾回收已经扫描完根对象（此时根对象为黑色）并继续扫描期间，白色对象Z正被一个灰色对象引用，但此时工作协程在执行过程中，让黑色的根对象指向了白色的对象Z。由于黑色的对象不会被扫描，这将导致白色对象Z被视为垃圾对象最终被回收。
![[Pasted image 20220225122021.png]]
那么是不是黑色对象一定不能指向白色对象呢？其实也不一定。如图20-18所示，即便黑色对象引用了白色对象，但只要白色对象中有一条路径始终被灰色对象引用了，此白色对象就一定能被扫描到。
![[Pasted image 20220225122037.png]]
这其实引出了保证并发标记准确性需要遵守的原则，即强、弱三色不变性。强三色不变性指所有白色对象都不能被黑色对象引用，这是一种比较严格的要求。与之对应的是弱三色不变性，弱三色不变性允许白色对象被黑色对象引用，但是白色对象必须有一条路径始终是被灰色对象引用的，这保证了该对象最终能被扫描到。在并发标记写入和删除对象时，可能破坏三色不变性，因此必须有一种机制能够维护三色不变性，这就是屏障技术。屏障技术的原则是在写入或者删除对象时将可能活着的对象标记为灰色。上例如果能够在对象写入时将Z对象设置为灰色，那么Z对象最终将被扫描到，如图20-19所示。
![[Pasted image 20220225122106.png]]
![[Pasted image 20220225122126.png]]
![[Pasted image 20220225122135.png]]
还有一种常见的策略是在删除引用时做文章，如图20-20所示，Yuasa删除写屏障在对象被解除引用后，会立即将原引用对象标记为灰色。
![[Pasted image 20220225122155.png]]
这样即便没有写屏障，在插入操作时也不会破坏三色不变性，如图20-21所示，但是Z对象可能是垃圾对象。
插入屏障与删除屏障通过在写入和删除时重新标记颜色保证了三色不变性，解决了并发标记期间的准确性问题，但是它们都存在浮动垃圾的问题。插入屏障在删除引用时，可能标记一个已经变成垃圾的对象。而删除屏障在删除引用时可能把一个垃圾对象标记为灰色。这些是垃圾回收的精度问题，不会影响其准确性，因为浮动垃圾会在下一次垃圾回收中被回收。
插入屏障与删除屏障独立存在并能良好工作的前提是并发标记期间所有的写入操作都应用了屏障技术，但现实情况不会如此。大多数垃圾回收语言不会对栈上的操作或寄存器上的操作应用屏障技术，这是因为栈上操作是最频繁的，如果每个写入或删除操作都应用屏障技术则会大大减慢程序的速度。在Go 1.8之前，尽管使用了插入屏障，但是仍然需要在标记终止期间STW阶段重新扫描根对象，来保证三色标记的一致性。为了解决重复扫描的问题，Go 1.8之后使用了混合写屏障技术，结合了Dijkstra与Yuasa两种风格。
为了了解使用混合写屏障技术的原因，我们先来看一看单纯地插入屏障和删除屏障在现实中面临的困境。假设栈上初始状态如图20-22所示，栈上变量p指向堆区内存，如果现在垃圾回收扫描完了根对象，那么old变量是不会被扫描的。
![[Pasted image 20220225144531.png]]
进入到并发标记阶段之后，假设并发标记阶段如图20-23所示，old对象引用了p.x，但是赋值给栈上的变量不会经过写屏障。如果下一步p.x引用了一个新的内存对象k，并把k标记为灰色，但是并不把原始对象标记为灰色，那么这时原始对象即便被栈上的对象old标记也无法被扫描到。所以，必须在p.x=&k时应用删除屏障，在取消引用时，将p.x的原值标记为灰色。
![[Pasted image 20220225144556.png]]
如果只有删除屏障而没有写屏障，那么也会面临问题。假设根对象未开始扫描，对象全为白色，栈上变量p引用堆区对象o，栈上变量a引用堆区对象k，在并发标记期间，扫描完变量p还未扫描变量a时的情形如图20-24所示。
![[Pasted image 20220225144821.png]]
此时，工作协程将变量a置为nil，p.x=&k将对象p指向了k。如果只存在删除屏障而不启用写屏障（不标记新的k值），那么会违背三色不变性，让黑色对象引用白色对象。导致k无法被标记，如图20-25所示。
![[Pasted image 20220225145904.png]]
因此，要想在标记终止阶段不用重新扫描根对象，需要使用写屏障与删除屏障混合的屏障技术，其伪代码如下：
在Go语言中，混合写屏障技术的实现依赖编译时与运行时的共同努力。在标记准备阶段的STW阶段会打开写屏障
编译器会在所有堆写入或删除操作前判断当前是否为垃圾回收标记阶段，如果是则会执行对应的混合写屏障标记对象。在汇编代码中表示如下，其中，gcWriteBarrier是与平台相关的汇编代码，执行标记逻辑。
Go语言中构建了如图20-26所示的写屏障指针缓存池，gcWriteBarrier先将所有被标记的指针放入缓存池中，并在容量满后，一次性全部刷新到扫描任务池中。最终这些被标记的指针都将被扫描。
![[Pasted image 20220225150132.png]]
## 垃圾清扫
垃圾标记工作完成意味着已经追踪到内存中所有活着的对象（虽然可能有一些浮动垃圾），之后进入垃圾清扫阶段，将垃圾对象的内存回收重用或返还给操作系统。注意，程序中只有一个垃圾清扫协程，并在清扫阶段与用户协程同时运行。
当清扫协程被唤醒后，会开始垃圾清扫。垃圾清扫采取了懒清扫的策略，即执行少量清扫工作后，通过Gosched函数让渡自己的执行权利，不需要一直执行。因此当触发下一阶段的垃圾回收后，可能有没有被清理的内存，需要先将它们清理完。
### 懒清扫逻辑
清扫是以span为单位进行的，sweepone函数的作用是找到一个span并进行相应的清扫工作。先从mheap中的sweepSpans队列中取出需要清扫的span。
![[Pasted image 20220225150617.png]]
sweepSpans数组的长度为2，sweepSpans[sweepgen/2%2]保存当前正在使用的span列表，sweepSpans[1-sweepgen/2%2]保存等待清扫的span列表，由于sweepgen每次清扫时加2。
![[Pasted image 20220225150645.png]]
因此sweepSpans [0]、sweepSpans [1]每次清扫时互相交换身份，即本次正在使用的span列表将是下一次GC待清扫的列表。
在清扫span期间，最重要的一步是将gcmarkBits位图赋值给allocBits位图，如图20-27所示。
![[Pasted image 20220225151253.png]]
当前gcmarkBits是GC标记后最新的对象位图，当gcmarkBits中的bit位为1时，代表当前对象是活着的。所以，当gcmarkBits中的某一个bit位为1，但是对应的allocBits位图中的bit位为0时，代表这个对象是会被回收的垃圾对象。完成这一切换后，就可以通过位图使用已经是垃圾对象的内存了。
当前gcmarkBits是GC标记后最新的对象位图，当gcmarkBits中的bit位为1时，代表当前对象是活着的。所以，当gcmarkBits中的某一个bit位为1，但是对应的allocBits位图中的bit位为0时，代表这个对象是会被回收的垃圾对象。完成这一切换后，就可以通过位图使用已经是垃圾对象的内存了。
![[Pasted image 20220225151505.png]]
如果GC后gcmarkBits的全部bit位都为0，那么意味着当前所有span中的对象都不会再被其他对象引用（大对象比较特殊，因为其span内部只有一个对象）。
这时，整个span将会被mheap回收，并更新整个基数树（参考第18章），表明当前span的整个空间都可以被程序再次使用。如果当前span的整个空间并不完全为空，那么span会被重新放入sweepSpans正在使用的span列表中。
可以看出，这种回收方式并没有直接将内存释放到操作系统中，而是再次组织内存以便能在下次内存分配时利用已经被回收的内存。
### 辅助清除
我们已经知道，清扫是通过懒清扫的形式进行的，因此，在下次触发GC时，必须将上一次GC未清扫的span全部扫描。如果剩余的未清扫span太多，那么将大大拖后下一次GC开始的时间。为了规避这一问题，Go语言使用了辅助清扫的手段，这是在Go 1.5之后，和并发GC同时推出的。
辅助清扫即工作协程必须在适当的时机执行辅助清扫工作，以避免下一次GC发生时还有大量的未清扫span。判断是否需要清扫的最好时机是在工作协程分配内存时。
目前Go语言会在两个时机判断是否需要辅助扫描。一个是在需要向mcentrel申请内存时，一个在是大对象分配时。在这两个时间会判断当前已经清扫的page数大于清理的目标page数这个条件是否成立，如果不成立则会进行辅助清扫直到条件成立。
可以看出，辅助标记策略会尽可能地保证在下次触发GC时，已经扫描了所有待扫描的span。

## 系统驻留内存清除
驻留内存（RSS）是主内存（RAM）保留的进程占用的内存部分，是从操作系统中分配的内存。
为了将系统分配的内存保持在适当的大小，同时回收不再被使用的内存，Go语言使用了单独的后台清扫协程来清除内存。后台清扫协程目前是在程序开始时启动的，并且只启动一个。
清除策略占用当前线程CPU 1%的时间进行清除，因此，在大部分时间里，该协程处于休眠状态。bgscavenge花了很大的精力来计算和调整时间，以保证实现1%CPU执行时间的目标。因此如果清除花费的时间太多，那么休眠的时间也必须相应增加。
从伪代码中能看出一次只清除一个物理页。scavengeOne包含清扫的核心逻辑，其基本思路是在基数树中找到连续的没有被操作系统回收的内存，我们在介绍内存分配时提到过，基数树的叶子节点管理了一个chunk块大小的内存。对于每个chunk，都会有位图pallocBits管理其中每个page的内存分配。之前没有提到的是，scavenged是一个额外的位图，每一位与page的对应方式和分配位图pallocBits相似，但是含义不同。当bit位为1时，代表当前page已经被操作系统回收，因此当pallocBits中的某一位为1时，其对应的scavenged位必定为0。同时，只有当pallocBits与scavenged对应的位同时为0时，才表明其对应的page可以被清扫。
位图中每个bit位管理的page是固定的8KB，但是释放回操作系统中的内存至少为一个物理页大小。因此，实际可能需要释放n个page，即需要找到位图中连续可用的n个bit位。和分配时辅助查找的searchAddr字段一样，有一个辅助清扫的scavAddr字段，在系统驻留内存清扫时会从scavAddr之后进行搜索，而忽视掉scavAddr之前的地址，如图20-28所示。
![[Pasted image 20220225152319.png]]
在开始清除搜索时，会查找searchAddr所在的chunk块中是否存在即空闲又没有被清除的连续空间，如果查找不到，则通过基数树从上到下进行扫描，找到符合要求的区域。当查找到满足要求的连续空间后，就将scavenged位图的相应位置设置为1，更新scavAddr地址，将内存归还给操作系统，并更新相应的统计。
# 总结
垃圾回收是Go语言运行时最复杂的模块，Go语言采取了并发三色标记的垃圾回收策略，从根对象（协程栈、全局对象）出发查找所有被引用的对象。
为了解决并发垃圾回收带来的问题，Go语言分别引入了辅助标记、辅助清扫、系统驻留内存清除、混合写屏障等策略保证能够快速地执行垃圾回收而且尽可能不影响用户协程。在默认情况下，当占用内存达到上一次GC标记内存的2倍后将触发垃圾回收，在并发阶段，Go语言的目标是消耗25%的CPU执行后台标记协程。在清扫阶段，Go语言采取了懒清扫的策略，并且有专门的后台协程花费CPU 1%的时间执行系统驻留内存清除。
Go运行时暴露了一些API用于改变和查看垃圾回收的行为，例如runtime.GC函数、debug.SetGCPercent函数，以及第21章要介绍的pprof与trace工具。


### **开始 GC**

我们在测试的时候可以调用 `runtime.GC`来手动的触发 GC。但实际上，触发 GC 的入口一般不会手动调用。正常触发 GC 应该是在申请内存时会调用 `runtime.mallocgc`或者是 Go 后台的监控线程 sysmon 定时检查调用 `runtime.forcegchelper`。

```go
func GC() {
 // 获取 GC 循环次数
 n := atomic.Load(&work.cycles)
 // 等待上一个循环的标记终止、标记和清除终止阶段完成
 gcWaitOnMark(n)
 // 触发新一轮的 GC
 gcStart(gcTrigger{kind: gcTriggerCycle, n: n + 1})
 // 同上
 gcWaitOnMark(n + 1) 
 // 等待清理全部待处理的内存管理单元
 for atomic.Load(&work.cycles) == n+1 && sweepone() != ^uintptr(0) {
  sweep.nbgsweep++
  // 让出 P
  Gosched()
 } 

 for atomic.Load(&work.cycles) == n+1 && atomic.Load(&mheap_.sweepers) != 0 {
  Gosched()
 }
 
 mp := acquirem()
 cycle := atomic.Load(&work.cycles)
 if cycle == n+1 || (gcphase == _GCmark && cycle == n+2) {
  // 将该阶段的堆内存状态快照发布出来（ heap profile）
  mProf_PostSweep()
 }
 releasem(mp)
}
```

1.  首先会获取 GC 的循环次数，然后调用 gcWaitOnMark 等待上一个循环的标记终止、标记和清除终止阶段完成；
2.  调用 gcStart 触发新一轮的 GC，并且会调用 gcWaitOnMark 等待当前的循环的标记终止、标记和清除终止阶段完成；
3.  调用 sweepone 等待清理全部待处理的内存管理单元，然后调用 Gosched 让出 P；
4.  完成本轮垃圾收集的清理工作后，调用 mProf_PostSweep 将该阶段的堆内存状态快照发布出来；

### **GC 启动**
### 回收对象的流程

GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.  
首先GC有四个阶段, 它们分别是:

-   Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC
-   Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
-   Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)
-   Sweep: 按标记结果清扫span

下图是比较完整的GC流程, 并按颜色对这四个阶段进行了分类:

![](https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165749274-1840348396.png)

在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.  
标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.  
清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒.

目前整个GC流程会进行两次STW(Stop The World), 第一次是Mark阶段的开始, 第二次是Mark Termination阶段.  
第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).  
第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).  
需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.  
从go 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.

下图是比较完整的GC流程，可作为看源码时候的导航：

![](https://pic3.zhimg.com/80/v2-9065c1b2b81055a66f61bc9a3986c16a_720w.webp)

gcStart 函数比较长，下面分段来看看 gcStart：
```go
func gcStart(trigger gcTrigger) {
 ...
 // 验证垃圾收集条件 ,并清理已经被标记的内存单元
 for trigger.test() && sweepone() != ^uintptr(0) {
  sweep.nbgsweep++
 } 
 // 获取全局的 startSema信号量
 // 上锁, 然后重新检查gcTrigger的条件是否成立, 不成立时不触发GC
 semacquire(&work.startSema) 
 // 再次验证垃圾收集条件
 if !trigger.test() {
  semrelease(&work.startSema)
  return
 }
 // 检查是不是手动调用了 runtime.GC
 work.userForced = trigger.kind == gcTriggerCycle 
 
 semacquire(&gcsema)
 semacquire(&worldsema) 
 // 启动后台标记任务
 gcBgMarkStartWorkers()
 // 重置标记相关的状态
 systemstack(gcResetMarkState)

 // work 初始化工作
 work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs
 if work.stwprocs > ncpu { 
  work.stwprocs = ncpu
 } 
 work.heap0 = atomic.Load64(&memstats.heap_live)
 work.pauseNS = 0
 work.mode = mode 
 // 记录开始时间
 now := nanotime()
 work.tSweepTerm = now
 work.pauseStart = now
 // 暂停程序 STW
 systemstack(stopTheWorldWithSema) 
 // 在并发标记前，确保清理结束
 systemstack(func() {
  finishsweep_m()
 })
 // 清理sched.sudogcache 以及 sync.Pools
 clearpools()
 // GC 次数
 work.cycles++
 // 在开始 GC 之前清理控制器的状态,标记新一轮GC已开始
 gcController.startCycle()
 work.heapGoal = memstats.next_gc 
 // 设置全局变量中的GC状态为_GCmark
 // 然后启用写屏障
 setGCPhase(_GCmark)
 // 初始化后台扫描需要的状态
 gcBgMarkPrepare() // Must happen before assist enable.
 // 扫描栈上、全局变量等根对象并将它们加入队列
 gcMarkRootPrepare() 
 // 标记所有tiny alloc等待合并的对象
 gcMarkTinyAllocs() 
 // 启用 mutator  assists（协助线程）
 atomic.Store(&gcBlackenEnabled, 1)
 // 记录标记开始的时间
 gcController.markStartTime = now
 mp = acquirem()
 // 启动程序，后台任务也会开始标记堆中的对象
 systemstack(func() {
  now = startTheWorldWithSema(trace.enabled)
  // 记录停止了多久, 和标记阶段开始的时间
  work.pauseNS += now - work.pauseStart
  work.tMark = now
 }) 
 semrelease(&worldsema)
 ...
}
```
1.  两次调用 `trigger.test`检查是否满足垃圾收集的条件，这个函数我们在上面讲过了；
2.  调用 `semacquire(&work.startSema)`上锁，调用 `gcBgMarkStartWorkers`启动后台标记任务，这个我们后面重点说；
3.  对 work 结构体做初始化工作，设置垃圾收集需要的 Goroutine 数量以及已完成的GC 次数等；
4.  在开始 GC 之前调用 `gcController.startCycle` 清理控制器的状态，标记新一轮GC已开始；
5.  调用 setGCPhase 设置全局变量中的GC状态为 \_GCmark ，然后启用写屏障；
6.  调用 gcBgMarkPrepare 初始化后台扫描需要的状态；
7.  调用 gcMarkRootPrepare 将扫描栈上、全局变量等根对象并将它们加入队列；
8.  调用 gcMarkTinyAllocs 标记所有 tiny alloc 内存块；
9.  设置 gcBlackenEnabled ，启用 mutator assists（协助线程）；
10.  记录完标记开始的时间后，调用 startTheWorldWithSema 启动程序，后台任务也会开始标记堆中的对象；

下面这张图显示了 gcStart 过程中状态变化，以及 STW 停顿的方法，写屏障启用的周期：
![[Pasted image 20230321180553.png]]
上面只是粗略的说一下各个函数的作用，下面来分析一些重要的函数。
### finishsweep_m
[finishsweep_m](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L33)函数会清扫上一轮GC未清扫的span, 确保上一轮GC已完成:

```go
// finishsweep_m ensures that all spans are swept.
//
// The world must be stopped. This ensures there are no sweeps in
// progress.
//
//go:nowritebarrier
func finishsweep_m() {
	// sweepone会取出一个未sweep的span然后执行sweep
	// 详细将在下面sweep阶段时分析
	// Sweeping must be complete before marking commences, so
	// sweep any unswept spans. If this is a concurrent GC, there
	// shouldn't be any spans left to sweep, so this should finish
	// instantly. If GC was forced before the concurrent sweep
	// finished, there may be spans to sweep.
	for sweepone() != ^uintptr(0) {
		sweep.npausesweep++
	}

	// 所有span都sweep完成后, 启动一个新的markbit时代
	// 这个函数是实现span的gcmarkBits和allocBits的分配和复用的关键, 流程如下
	// - span分配gcmarkBits和allocBits
	// - span完成sweep
	//   - 原allocBits不再被使用
	//   - gcmarkBits变为allocBits
	//   - 分配新的gcmarkBits
	// - 开启新的markbit时代
	// - span完成sweep, 同上
	// - 开启新的markbit时代
	//   - 2个时代之前的bitmap将不再被使用, 可以复用这些bitmap
	nextMarkBitArenaEpoch()
}
```
### clearpools
[clearpools](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2065)函数会清理sched.sudogcache和sched.deferpool, 让它们的内存可以被回收:

```go
func clearpools() {
	// clear sync.Pools
	if poolcleanup != nil {
		poolcleanup()
	}

	// Clear central sudog cache.
	// Leave per-P caches alone, they have strictly bounded size.
	// Disconnect cached list before dropping it on the floor,
	// so that a dangling ref to one entry does not pin all of them.
	lock(&sched.sudoglock)
	var sg, sgnext *sudog
	for sg = sched.sudogcache; sg != nil; sg = sgnext {
		sgnext = sg.next
		sg.next = nil
	}
	sched.sudogcache = nil
	unlock(&sched.sudoglock)

	// Clear central defer pools.
	// Leave per-P pools alone, they have strictly bounded size.
	lock(&sched.deferlock)
	for i := range sched.deferpool {
		// disconnect cached list before dropping it on the floor,
		// so that a dangling ref to one entry does not pin all of them.
		var d, dlink *_defer
		for d = sched.deferpool[i]; d != nil; d = dlink {
			dlink = d.link
			d.link = nil
		}
		sched.deferpool[i] = nil
	}
	unlock(&sched.deferlock)
}
```
### **startCycle**

```go
func (c *gcControllerState) startCycle() {
	 c.scanWork = 0
	 c.bgScanCredit = 0
	 c.assistTime = 0
	 c.dedicatedMarkTime = 0
	 c.fractionalMarkTime = 0
	 c.idleMarkTime = 0
	 // 设置 next_gc 最小值 
	 if memstats.next_gc < memstats.heap_live+1024*1024 {
	  memstats.next_gc = memstats.heap_live + 1024*1024
	 }
	 // gcBackgroundUtilization 默认是 0.25
	 // 是GC所占的P的目标值
	 totalUtilizationGoal := float64(gomaxprocs) * gcBackgroundUtilization
	 // dedicatedMarkWorkersNeeded 等于P的数量的25% 加上 0.5 去掉小数点
	 c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal + 0.5)
	 utilError := float64(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - 1
	 const maxUtilError = 0.3
	 if utilError < -maxUtilError || utilError > maxUtilError {
	  if float64(c.dedicatedMarkWorkersNeeded) > totalUtilizationGoal {
	   c.dedicatedMarkWorkersNeeded--
	  }
	  // 是 gcMarkWorkerFractionalMode 的任务所占的P的目标值(
	  c.fractionalUtilizationGoal = (totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)) / float64(gomaxprocs)
	 } else {
	  c.fractionalUtilizationGoal = 0
	 }
	
	 if debug.gcstoptheworld > 0 {
	  c.dedicatedMarkWorkersNeeded = int64(gomaxprocs)
	  c.fractionalUtilizationGoal = 0
	 }
	 for _, p := range allp {
	  p.gcAssistTime = 0
	  p.gcFractionalMarkTime = 0
	 }
	 // 计算协助GC的参数
	 c.revise()
}
```

这里需要注意的是 dedicatedMarkWorkersNeeded 与 fractionalUtilizationGoal 的计算过程，这个会在计算 work 工作模式的用到。
一种简单的想法,要实现后台标记协程消耗的CPU接近于25%的目标，可以根据当前有多少逻辑处理器P，开启的数量应该为0.25 * P 就可以了。为什么startCycle函数的计算过程却如此复杂呢？关键在于需要处理当协程数量过小，例如P≤3时，0.25 * P 不为整数的情况。

dedicatedMarkWorkersNeeded代表了执行完整的后台标记协程的数量.例如当p=4时，dedicatedMarkWorkersNeeded = 1 。

![](https://pic3.zhimg.com/80/v2-4682e960a7b054c9d21883fcd5574516_720w.webp)

  

而fractionalUtilizationGoal是一个附加的参数，其小于1，例如当P=2时，值为0.25。代表了每个P在标记阶段需要花25%的时间去执行后台标记协程。

![](https://pic3.zhimg.com/80/v2-232038b4aa7bf2916c363050d8cedc82_720w.webp)

设计fractionalUtilizationGoal的主要目的是专门为P=1，2，3，6时使用的。 因为这些数量和25%的CPU处理时间的差距太大。 比如当P=2时，这时2*0.25 = 0.5,即只能花0.5个P来执行标记任务，但如果专门用了一个P来执行后台任务，这时标记的CPU使用量变为了1/2 =0.5, 这和0.25CPU的设计目标差距太大。

所以，当P=2时，fractionalUtilizationGoal计算结果为0.25，它表明在整个并发标记的周期t内，每一个P都需要花25%的时间来执行后台标记工作。这是一种基于时间的调度安排。当超出时间后，意味着当前的后台标记协程可以被抢占，从而执行其他的协程。

### gcMarkRootPrepare
[gcMarkRootPrepare](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54)函数会计算扫描根对象的任务数量:

```go
// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and
// some miscellany) and initializes scanning-related state.
//
// The caller must have call gcCopySpans().
//
// The world must be stopped.
//
//go:nowritebarrier
func gcMarkRootPrepare() {
	// 释放mcache中的所有span的任务, 只在完成标记阶段(mark termination)中执行
	if gcphase == _GCmarktermination {
		work.nFlushCacheRoots = int(gomaxprocs)
	} else {
		work.nFlushCacheRoots = 0
	}

	// 计算block数量的函数, rootBlockBytes是256KB
	// Compute how many data and BSS root blocks there are.
	nBlocks := func(bytes uintptr) int {
		return int((bytes + rootBlockBytes - 1) / rootBlockBytes)
	}

	work.nDataRoots = 0
	work.nBSSRoots = 0

	// data和bss每一轮GC只扫描一次
	// 并行GC中会在后台标记任务中扫描, 完成标记阶段(mark termination)中不扫描
	// 非并行GC会在完成标记阶段(mark termination)中扫描
	// Only scan globals once per cycle; preferably concurrently.
	if !work.markrootDone {
		// 计算扫描可读写的全局变量的任务数量
		for _, datap := range activeModules() {
			nDataRoots := nBlocks(datap.edata - datap.data)
			if nDataRoots > work.nDataRoots {
				work.nDataRoots = nDataRoots
			}
		}

		// 计算扫描只读的全局变量的任务数量
		for _, datap := range activeModules() {
			nBSSRoots := nBlocks(datap.ebss - datap.bss)
			if nBSSRoots > work.nBSSRoots {
				work.nBSSRoots = nBSSRoots
			}
		}
	}

	// span中的finalizer和各个G的栈每一轮GC只扫描一次
	// 同上
	if !work.markrootDone {
		// 计算扫描span中的finalizer的任务数量
		// On the first markroot, we need to scan span roots.
		// In concurrent GC, this happens during concurrent
		// mark and we depend on addfinalizer to ensure the
		// above invariants for objects that get finalizers
		// after concurrent mark. In STW GC, this will happen
		// during mark termination.
		//
		// We're only interested in scanning the in-use spans,
		// which will all be swept at this point. More spans
		// may be added to this list during concurrent GC, but
		// we only care about spans that were allocated before
		// this mark phase.
		work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()

		// 计算扫描各个G的栈的任务数量
		// On the first markroot, we need to scan all Gs. Gs
		// may be created after this point, but it's okay that
		// we ignore them because they begin life without any
		// roots, so there's nothing to scan, and any roots
		// they create during the concurrent phase will be
		// scanned during mark termination. During mark
		// termination, allglen isn't changing, so we'll scan
		// all Gs.
		work.nStackRoots = int(atomic.Loaduintptr(&allglen))
	} else {
		// We've already scanned span roots and kept the scan
		// up-to-date during concurrent mark.
		work.nSpanRoots = 0

		// The hybrid barrier ensures that stacks can't
		// contain pointers to unmarked objects, so on the
		// second markroot, there's no need to scan stacks.
		work.nStackRoots = 0

		if debug.gcrescanstacks > 0 {
			// Scan stacks anyway for debugging.
			work.nStackRoots = int(atomic.Loaduintptr(&allglen))
		}
	}

	// 计算总任务数量
	// 后台标记任务会对markrootNext进行原子递增, 来决定做哪个任务
	// 这种用数值来实现锁自由队列的办法挺聪明的, 尽管google工程师觉得不好(看后面markroot函数的分析)
	work.markrootNext = 0
	work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)
}
```

### **标记 tiny alloc**

```go
func gcMarkTinyAllocs() {
 for _, p := range allp {
        // 标记各个 P 中的 mcache 中的 tiny
  c := p.mcache
  if c == nil || c.tiny == 0 {
   continue
  }
  _, span, objIndex := findObject(c.tiny, 0, 0)
  gcw := &p.gcw
        // 标记存活对象，并把它加到 gcwork 标记队列
  greyobject(c.tiny, 0, 0, span, gcw, objIndex)
 }
}
```

tiny block 这个数据结构也在内存分配那一节讲过了，这里主要是会把所有 P 中的 mcache 中的 tiny 找到并进行标记，然后把它加到 gcwork 标记队列，至于什么是 gcwork 标记队列，我们下面在执行标记的地方会讲到。
### **write Barrier 写屏障**

在设置 GC 阶段标记的时候会根据当前的设置的值来判断是否需要开启 write Barrier ：

```go
func setGCPhase(x uint32) {
 atomic.Store(&gcphase, x)
 writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
 writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
}
```

编译器会在`src\cmd\compile\internal\ssa\writebarrier.go`中调用 writebarrier 函数，就如同它的注释所说：

> // writebarrier pass inserts write barriers for store ops (Store, Move, Zero) // when necessary (the condition above). It rewrites store ops to branches // and runtime calls, like // // if writeBarrier.enabled { // gcWriteBarrier(ptr, val) // Not a regular Go call // } else { // \*ptr = val // }  

在执行 Store, Move, Zero 等汇编操作的时候加入写屏障。

我们可以通过 dlv 断点找到 gcWriteBarrier 汇编代码的位置在 `go/src/runtime/asm_amd64.s:1395`。该汇编函数会调用 `runtime.wbBufFlush`将 write barrier 的缓存任务添加到 GC 的工作队列中进行处理。

```go
func wbBufFlush(dst *uintptr, src uintptr) {
 ...
 systemstack(func() {
  ...
  wbBufFlush1(getg().m.p.ptr())
 })
}

func wbBufFlush1(_p_ *p) {
 // 获取缓存的指针
 start := uintptr(unsafe.Pointer(&_p_.wbBuf.buf[0]))
 n := (_p_.wbBuf.next - start) / unsafe.Sizeof(_p_.wbBuf.buf[0])
 ptrs := _p_.wbBuf.buf[:n]

 _p_.wbBuf.next = 0

   
 gcw := &_p_.gcw
 pos := 0
 for _, ptr := range ptrs {
  // 查找到对象
  obj, span, objIndex := findObject(ptr, 0, 0)
  if obj == 0 {
   continue
  } 
  mbits := span.markBitsForIndex(objIndex)
  // 判断是否已被标记
  if mbits.isMarked() {
   continue
  }
  // 进行标记
  mbits.setMarked()

  // 标记 span.
  arena, pageIdx, pageMask := pageIndexOf(span.base())
  if arena.pageMarks[pageIdx]&pageMask == 0 {
   atomic.Or8(&arena.pageMarks[pageIdx], pageMask)
  }

  if span.spanclass.noscan() {
   gcw.bytesMarked += uint64(span.elemsize)
   continue
  }
  ptrs[pos] = obj
  pos++
 }

 // 将对象加入到 gcWork队列中
 gcw.putBatch(ptrs[:pos]) 
 // 重置 write barrier 缓存
 _p_.wbBuf.reset()
}
```

写屏障这里其实也是和并发标记是一样的套路，可以看完并发标记再过来看。wbBufFlush1 会遍历write barrier 缓存，然后调用 findObject 查找到对象之后使用标志位进行标记，最后将对象加入到 gcWork队列中进行扫描，并 重置 write barrier 缓存。

### **stopTheWorldWithSema 与 startTheWorldWithSema**

stopTheWorldWithSema 与 startTheWorldWithSema 是一对用于暂停和恢复程序的核心函数。

```go
func stopTheWorldWithSema() {
 _g_ := getg() 

 lock(&sched.lock)
 // 需要停止的P数量
 sched.stopwait = gomaxprocs
 // 标记 gcwaiting，调度时看见此标记会进入等待
 atomic.Store(&sched.gcwaiting, 1)
 // 发送抢占信号
 preemptall() 
 // 暂停当前 P
 _g_.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic.
 // 减少需要停止的P数量(当前的P算一个)
 sched.stopwait--
 // 遍历所有的 P ，修改 P 的状态为 _Pgcstop 停止运行
 for _, p := range allp {
  s := p.status
  if s == _Psyscall && atomic.Cas(&p.status, s, _Pgcstop) {
   if trace.enabled {
    traceGoSysBlock(p)
    traceProcStop(p)
   }
   p.syscalltick++
   sched.stopwait--
  }
 }
 // 停止空闲的 P 列表
 for {
  p := pidleget()
  if p == nil {
   break
  }
  p.status = _Pgcstop
  sched.stopwait--
 }
 wait := sched.stopwait > 0
 unlock(&sched.lock)
 // 如果仍有需要停止的P, 则等待它们停止
 if wait {
  for {
   //  等待 100 us
   if notetsleep(&sched.stopnote, 100*1000) {
    noteclear(&sched.stopnote)
    break
   }
   // 再次进行发送抢占信号
   preemptall()
  }
 }
 // 安全检测
 bad := ""
 if sched.stopwait != 0 {
  bad = "stopTheWorld: not stopped (stopwait != 0)"
 } else {
  for _, p := range allp {
   if p.status != _Pgcstop {
    bad = "stopTheWorld: not stopped (status != _Pgcstop)"
   }
  }
 }
 if atomic.Load(&freezing) != 0 {
  lock(&deadlock)
  lock(&deadlock)
 }
 if bad != "" {
  throw(bad)
 }
 // 到这里所有运行中的G都会变为待运行, 并且所有的P都不能被M获取 
 // 也就是说所有的go代码(除了当前的)都会停止运行, 并且不能运行新的go代码
}
```

这个方法会通过`sched.stopwait`来检测是否所有的 P 都已暂停。首先会通过调用 preemptall 发送抢占信号进行抢占所有运行中的 G，然后遍历 P 将所有状态为 \_Psyscall、空闲的 P 都暂停，如果仍有需要停止的P, 则等待它们停止。

```go
func startTheWorldWithSema(emitTraceEvent bool) int64 {
	 mp := acquirem() // disable preemption because it can be holding p in a local var
	 // 判断收到的 netpoll 事件并添加对应的G到待运行队列
	 if netpollinited() {
	  list := netpoll(0) // non-blocking
	  injectglist(&list)
	 }
	 lock(&sched.lock)
	
	 procs := gomaxprocs
	 if newprocs != 0 {
	  procs = newprocs
	  newprocs = 0
	 }
	  // 扩容或者缩容全局的处理器
	 p1 := procresize(procs)
	 // 取消GC等待标记
	 sched.gcwaiting = 0
	 // 如果 sysmon （后台监控线程） 在等待则唤醒它
	 if sched.sysmonwait != 0 {
	  sched.sysmonwait = 0
	  notewakeup(&sched.sysmonnote)
	 }
	 unlock(&sched.lock)
	 // 唤醒有可运行任务的P
	 for p1 != nil {
	  p := p1
	  p1 = p1.link.ptr()
	  if p.m != 0 {
	   mp := p.m.ptr()
	   p.m = 0
	   if mp.nextp != 0 {
	    throw("startTheWorld: inconsistent mp->nextp")
	   }
	   mp.nextp.set(p)
	   notewakeup(&mp.park)
	  } else {
	   // Start M to run P 
	   newm(nil, p, -1)
	  }
	 } 
	 startTime := nanotime()
	 if emitTraceEvent {
	  traceGCSTWDone()
	 }
	  // 如果有空闲的P，并且没有自旋中的M则唤醒或者创建一个M
	 wakep() 
	 releasem(mp) 
	 return startTime
}
```

startTheWorldWithSema 就显得简单的多，首先从 netpoller 中获取待处理的任务并加入全局队列；然后遍历 P 链表，唤醒有可运行任务的P。

### **创建后台标记 Worker**

```go
func gcBgMarkStartWorkers() {
	 // 遍历所有 P
	 for _, p := range allp {
		    // 如果已启动则不重复启动
		  if p.gcBgMarkWorker == 0 {
			    // 为全局每个处理器创建用于执行后台标记任务的 Goroutine
			   go gcBgMarkWorker(p)
			    // 启动后等待该任务通知信号量 bgMarkReady 再继续
			   notetsleepg(&work.bgMarkReady, -1)
			   noteclear(&work.bgMarkReady)
		  }
	 }
}
```

gcBgMarkStartWorkers 会为全局每个 P 创建用于执行后台标记任务的 Goroutine，每一个 Goroutine 都会运行 gcBgMarkWorker，notetsleepg 会等待 gcBgMarkWorker 通知信号量 bgMarkReady 再继续。

这里虽然为每个 P 启动了一个后台标记任务, 但是可以同时工作的只有 25%，调度器在调度循环 `runtime.schedule`中通过调用 `gcController.findRunnableGCWorker`方法进行控制。

在看这个方法之前，先来了解一个概念， Mark Worker Mode 标记工作模式，目前来说有三种，这三种是为了保证后台的标记线程的利用率。

```go
type gcMarkWorkerMode int

const (
 // gcMarkWorkerDedicatedMode indicates that the P of a mark
 // worker is dedicated to running that mark worker. The mark
 // worker should run without preemption.
 gcMarkWorkerDedicatedMode gcMarkWorkerMode = iota

 // gcMarkWorkerFractionalMode indicates that a P is currently
 // running the "fractional" mark worker. The fractional worker
 // is necessary when GOMAXPROCS*gcBackgroundUtilization is not
 // an integer. The fractional worker should run until it is
 // preempted and will be scheduled to pick up the fractional
 // part of GOMAXPROCS*gcBackgroundUtilization.
 gcMarkWorkerFractionalMode

 // gcMarkWorkerIdleMode indicates that a P is running the mark
 // worker because it has nothing else to do. The idle worker
 // should run until it is preempted and account its time
 // against gcController.idleMarkTime.
 gcMarkWorkerIdleMode
)
```

通过代码注释可以知道：

-   gcMarkWorkerDedicatedMode ：P 专门负责标记对象，不会被调度器抢占；
-   gcMarkWorkerFractionalMode：主要是由于现在默认标记线程的占用率要为 25%，所以如果 CPU 核数不是4的倍数，就无法除得整数，启动该类型的工作模式帮助垃圾收集达到利用率的目标；
-   gcMarkWorkerIdleMode：表示 P 当前只有标记线程在跑，没有其他可以执行的 G ，它会运行垃圾收集的标记任务直到被抢占；

```go
func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {
	 ...
	 // 原子减少对应的值, 如果减少后大于等于0则返回true, 否则返回false
	 decIfPositive := func(ptr *int64) bool {
	  if *ptr > 0 {
	   if atomic.Xaddint64(ptr, -1) >= 0 {
	    return true
	   }
	   // We lost a race
	   atomic.Xaddint64(ptr, +1)
	  }
	  return false
	 }
	 // 减少dedicatedMarkWorkersNeeded, 成功时后台标记任务的模式是Dedicated
	 if decIfPositive(&c.dedicatedMarkWorkersNeeded) { 
		  _p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode
	 } else if c.fractionalUtilizationGoal == 0 {
		  // No need for fractional workers.
		  return nil
	 } else {
	  // 执行标记任务的时间
	  delta := nanotime() - gcController.markStartTime 
	  if delta > 0 && float64(_p_.gcFractionalMarkTime)/float64(delta) > c.fractionalUtilizationGoal {
	   // Nope. No need to run a fractional worker.
	   return nil
	  }
	  _p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode
	 }
	 
	 gp := _p_.gcBgMarkWorker.ptr()
	 casgstatus(gp, _Gwaiting, _Grunnable) 
	 return gp
}
```

在 findRunnableGCWorker 会通过 dedicatedMarkWorkersNeeded 来决定是否采用 gcMarkWorkerDedicatedMode 的 Mark Worker Mode 标记工作模式。dedicatedMarkWorkersNeeded 是在 `gcControllerState.startCycle`中进行初始化。

公式我就不贴了，在 `gcControllerState.startCycle`已经讲过了，通俗来说如果当前是 8 核 CPU，那么 dedicatedMarkWorkersNeeded 为 2 ，如果是 6 核 CPU，因为无法被 4 整除，计算得 dedicatedMarkWorkersNeeded 为 1，所以需要上面得 gcMarkWorkerFractionalMode 模式来保证 CPU 的利用率。

gcMarkWorkerIdleMode 会在调度器执行 findrunnable 抢占的时候调用：

```go
func findrunnable() (gp *g, inheritTime bool) {
 ...
stop:
    // 处于 GC 阶段的话，获取执行GC标记任务的G
    if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
        _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode
        gp := _p_.gcBgMarkWorker.ptr()
        //将本地 P 的 GC 标记专用 G 职位 Grunnable
        casgstatus(gp, _Gwaiting, _Grunnable) 
        return gp, false
    }
 ...
}
```

看过我的《详解Go语言调度循环源码实现》的同学应该都知道，抢占调度运行到这里的时候，通常是 P 抢占不到 G 了，打算进行休眠了，因此在休眠之前可以安全的进行标记任务的执行。

### **并发扫描标记**

并发扫描标记可以大概概括为以下几个部分：

1.  将当前传入的 P 打包成 parkInfo ，然后调用 gopark 让当前 G 进入休眠，在休眠前会将 P 的 gcBgMarkWorker 与 G 进行绑定，等待唤醒；
2.  根据 Mark Worker Mode 调用不同的策略调用 gcDrain 执行标记；
3.  判断是否所有后台标记任务都完成, 并且没有更多的任务，调用 gcMarkDone 准备进入完成标记阶段；

### **后台标记休眠等待**

```go
func gcBgMarkWorker(_p_ *p) {
	gp := getg()
	
	// 用于休眠后重新获取P的构造体
	type parkInfo struct {
		m      muintptr // Release this m on park.
		attach puintptr // If non-nil, attach to this p on park.
	}
	// We pass park to a gopark unlock function, so it can't be on
	// the stack (see gopark). Prevent deadlock from recursively
	// starting GC by disabling preemption.
	gp.m.preemptoff = "GC worker init"
	park := new(parkInfo)
	gp.m.preemptoff = ""
	
	// 设置当前的M并禁止抢占
	park.m.set(acquirem())
	// 设置当前的P(需要关联到的P)
	park.attach.set(_p_)
	
	// 通知gcBgMarkStartWorkers可以继续处理
	// Inform gcBgMarkStartWorkers that this worker is ready.
	// After this point, the background mark worker is scheduled
	// cooperatively by gcController.findRunnable. Hence, it must
	// never be preempted, as this would put it into _Grunnable
	// and put it on a run queue. Instead, when the preempt flag
	// is set, this puts itself into _Gwaiting to be woken up by
	// gcController.findRunnable at the appropriate time.
	notewakeup(&work.bgMarkReady)
	
	for {
		// 让当前G进入休眠
		// Go to sleep until woken by gcController.findRunnable.
		// We can't releasem yet since even the call to gopark
		// may be preempted.
		gopark(func(g *g, parkp unsafe.Pointer) bool {
			park := (*parkInfo)(parkp)
			
			// 重新允许抢占
			// The worker G is no longer running, so it's
			// now safe to allow preemption.
			releasem(park.m.ptr())
			
			// 设置关联的P
			// 把当前的G设到P的gcBgMarkWorker成员, 下次findRunnableGCWorker会使用
			// 设置失败时不休眠
			// If the worker isn't attached to its P,
			// attach now. During initialization and after
			// a phase change, the worker may have been
			// running on a different P. As soon as we
			// attach, the owner P may schedule the
			// worker, so this must be done after the G is
			// stopped.
			if park.attach != 0 {
				p := park.attach.ptr()
				park.attach.set(nil)
				// cas the worker because we may be
				// racing with a new worker starting
				// on this P.
				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {
					// The P got a new worker.
					// Exit this worker.
					return false
				}
			}
			return true
		}, unsafe.Pointer(park), "GC worker (idle)", traceEvGoBlock, 0)
		
		// 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务
		// Loop until the P dies and disassociates this
		// worker (the P may later be reused, in which case
		// it will get a new worker) or we failed to associate.
		if _p_.gcBgMarkWorker.ptr() != gp {
			break
		}
		
		// 禁止G被抢占
		// Disable preemption so we can use the gcw. If the
		// scheduler wants to preempt us, we'll stop draining,
		// dispose the gcw, and then preempt.
		park.m.set(acquirem())
		
		if gcBlackenEnabled == 0 {
			throw("gcBgMarkWorker: blackening not enabled")
		}
		
		// 记录开始时间
		startTime := nanotime()
		
		decnwait := atomic.Xadd(&work.nwait, -1)
		if decnwait == work.nproc {
			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
			throw("work.nwait was > work.nproc")
		}
		
		// 切换到g0运行
		systemstack(func() {
			// 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈)
			// Mark our goroutine preemptible so its stack
			// can be scanned. This lets two mark workers
			// scan each other (otherwise, they would
			// deadlock). We must not modify anything on
			// the G stack. However, stack shrinking is
			// disabled for mark workers, so it is safe to
			// read from the G stack.
			casgstatus(gp, _Grunning, _Gwaiting)
			
			// 判断后台标记任务的模式
			switch _p_.gcMarkWorkerMode {
			default:
				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")
			case gcMarkWorkerDedicatedMode:
				// 这个模式下P应该专心执行标记
				// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
				gcDrain(&_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
				// 被抢占时把本地运行队列中的所有G都踢到全局运行队列
				if gp.preempt {
					// We were preempted. This is
					// a useful signal to kick
					// everything out of the run
					// queue so it can run
					// somewhere else.
					lock(&sched.lock)
					for {
						gp, _ := runqget(_p_)
						if gp == nil {
							break
						}
						globrunqput(gp)
					}
					unlock(&sched.lock)
				}
				// 继续执行标记, 直到无更多任务, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
				// Go back to draining, this time
				// without preemption.
				gcDrain(&_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)
			case gcMarkWorkerFractionalMode:
				// 这个模式下P应该适当执行标记
				// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
				gcDrain(&_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
			case gcMarkWorkerIdleMode:
				// 这个模式下P只在空闲时执行标记
				// 执行标记, 直到被抢占或者达到一定的量, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
				gcDrain(&_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)
			}
			
			// 恢复G的状态到运行中
			casgstatus(gp, _Gwaiting, _Grunning)
		})
		
		// 如果标记了禁止本地标记队列则flush到全局标记队列
		// If we are nearing the end of mark, dispose
		// of the cache promptly. We must do this
		// before signaling that we're no longer
		// working so that other workers can't observe
		// no workers and no work while we have this
		// cached, and before we compute done.
		if gcBlackenPromptly {
			_p_.gcw.dispose()
		}
		
		// 累加所用时间
		// Account for time.
		duration := nanotime() - startTime
		switch _p_.gcMarkWorkerMode {
		case gcMarkWorkerDedicatedMode:
			atomic.Xaddint64(&gcController.dedicatedMarkTime, duration)
			atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 1)
		case gcMarkWorkerFractionalMode:
			atomic.Xaddint64(&gcController.fractionalMarkTime, duration)
			atomic.Xaddint64(&gcController.fractionalMarkWorkersNeeded, 1)
		case gcMarkWorkerIdleMode:
			atomic.Xaddint64(&gcController.idleMarkTime, duration)
		}
		
		// Was this the last worker and did we run out
		// of work?
		incnwait := atomic.Xadd(&work.nwait, +1)
		if incnwait > work.nproc {
			println("runtime: p.gcMarkWorkerMode=", _p_.gcMarkWorkerMode,
				"work.nwait=", incnwait, "work.nproc=", work.nproc)
			throw("work.nwait > work.nproc")
		}
		
		// 判断是否所有后台标记任务都完成, 并且没有更多的任务
		// If this worker reached a background mark completion
		// point, signal the main GC goroutine.
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
			// 取消和P的关联
			// Make this G preemptible and disassociate it
			// as the worker for this P so
			// findRunnableGCWorker doesn't try to
			// schedule it.
			_p_.gcBgMarkWorker.set(nil)
			
			// 允许G被抢占
			releasem(park.m.ptr())
			
			// 准备进入完成标记阶段
			gcMarkDone()
			
			// 休眠之前会重新关联P
			// 因为上面允许被抢占, 到这里的时候可能就会变成其他P
			// 如果重新关联P失败则这个任务会结束
			// Disable preemption and prepare to reattach
			// to the P.
			//
			// We may be running on a different P at this
			// point, so we can't reattach until this G is
			// parked.
			park.m.set(acquirem())
			park.attach.set(_p_)
		}
	}
}
```

在 gcBgMarkStartWorkers 中我们看到，它会遍历所有的 P ，然后为每个 P 创建一个负责 Mark Work 的 G，这里虽然为每个 P 启动了一个后台标记任务, 但是不可能每个 P 都会去执行标记任务，后台标记任务默认资源占用率是 25%，所以 gcBgMarkWorker 中会初始化 park 并将 G 和 P 的 gcBgMarkWorker 进行绑定后进行休眠。

调度器在调度循环 `runtime.schedule`中通过调用 `gcController.findRunnableGCWorker`方法进行控制，让哪些 Mark Work 可以执行，上面代码已经贴过了，这里就不重复了。

![](https://pic1.zhimg.com/80/v2-51092ae99ce4221ab45d18ddf3889860_720w.webp)

### **后台标记**

在唤醒后，我们会根据 gcMarkWorkerMode 选择不同的标记执行策略，不同的执行策略都会调用 `runtime.gcDrain` :

```go
func gcBgMarkWorker(_p_ *p) {
 gp := getg()
 ...
 for { 
  ...
  // 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务
  if _p_.gcBgMarkWorker.ptr() != gp {
   break
  }
  // 禁止G被抢占
  park.m.set(acquirem())

  // 记录开始时间
  startTime := nanotime()
  _p_.gcMarkWorkerStartTime = startTime

  decnwait := atomic.Xadd(&work.nwait, -1)

  systemstack(func() { 
   // 设置G的状态为等待中这样它的栈可以被扫描
   casgstatus(gp, _Grunning, _Gwaiting)
   // 判断后台标记任务的模式
   switch _p_.gcMarkWorkerMode {
   default:
    throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")
   case gcMarkWorkerDedicatedMode:
    // 这个模式下P应该专心执行标记
    gcDrain(&_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
    if gp.preempt { 
     // 被抢占时把本地运行队列中的所有G都踢到全局运行队列
     lock(&sched.lock)
     for {
      gp, _ := runqget(_p_)
      if gp == nil {
       break
      }
      globrunqput(gp)
     }
     unlock(&sched.lock)
    }
    // 继续执行标记
    gcDrain(&_p_.gcw, gcDrainFlushBgCredit)
   case gcMarkWorkerFractionalMode:
    // 执行标记
    gcDrain(&_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)
   case gcMarkWorkerIdleMode:
    // 执行标记, 直到被抢占或者达到一定的量
    gcDrain(&_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)
   }
   // 恢复G的状态到运行中
   casgstatus(gp, _Gwaiting, _Grunning)
  }) 
  ...
 }
}
```

在上面已经讲了不同的 Mark Worker Mode 的区别，不记得的同学可以往上翻一下。执行标记这部分主要在 switch 判断中，根据不同的模式传入不同的参数到 gcDrain 函数中执行。

需要注意的是，传入到 gcDrain 中的是一个 gcWork 的结构体，它相当于每个 P 的私有缓存空间，存放需要被扫描的对象，为垃圾收集器提供了生产和消费任务的抽象，，该结构体持有了两个重要的工作缓冲区 `wbuf1` 和 `wbuf2`：

![](https://pic3.zhimg.com/80/v2-e4549d3f6960cec05984e69f2f8b46e2_720w.webp)

当我们向该结构体中增加或者删除对象时，它总会先操作 `wbuf1` 缓冲区，一旦 `wbuf1` 缓冲区空间不足或者没有对象，会触发缓冲区的切换，而当两个缓冲区空间都不足或者都为空时，会从全局的工作缓冲区中插入或者获取对象：

```go
func (w *gcWork) tryGet() uintptr {
	 wbuf := w.wbuf1
	 ...
	 // wbuf1缓冲区无数据时
	 if wbuf.nobj == 0 {
	  // wbuf1 与 wbuf2 进行对象互换
	  w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
	  wbuf = w.wbuf1
	  if wbuf.nobj == 0 {
		   owbuf := wbuf
		   // 从 work 的 full 队列中获取
		   wbuf = trygetfull()
		   ...
	  }
	 } 
	 wbuf.nobj--
	 return wbuf.obj[wbuf.nobj]
}
```

继续上面的 gcBgMarkWorker 方法，在标记完之后就要进行标记完成：

```go
func gcBgMarkWorker(_p_ *p) {
 gp := getg()
 ...
 for { 
  ...  
  // 累加所用时间
  duration := nanotime() - startTime
  switch _p_.gcMarkWorkerMode {
  case gcMarkWorkerDedicatedMode:
   atomic.Xaddint64(&gcController.dedicatedMarkTime, duration)
   atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 1)
  case gcMarkWorkerFractionalMode:
   atomic.Xaddint64(&gcController.fractionalMarkTime, duration)
   atomic.Xaddint64(&_p_.gcFractionalMarkTime, duration)
  case gcMarkWorkerIdleMode:
   atomic.Xaddint64(&gcController.idleMarkTime, duration)
  }

  incnwait := atomic.Xadd(&work.nwait, +1)
 
  // 判断是否所有后台标记任务都完成, 并且没有更多的任务
  if incnwait == work.nproc && !gcMarkWorkAvailable(nil) { 
   // 取消和P的关联
   _p_.gcBgMarkWorker.set(nil)
   // 允许G被抢占
   releasem(park.m.ptr())
   // 准备进入完成标记阶段
   gcMarkDone()

   // 休眠之前会重新关联P
   // 因为上面允许被抢占, 到这里的时候可能就会变成其他P
   // 如果重新关联P失败则这个任务会结束
   park.m.set(acquirem())
   park.attach.set(_p_)
  }
 }
}
```

gcBgMarkWorker 会根据 incnwait 来检查是否是最后一个 worker，然后调用 gcMarkWorkAvailable 函数来校验 gcwork的任务和全局任务是否已经全部都处理完了，如果都确认没问题，那么调用 gcMarkDone 进入完成标记阶段。

### **标记扫描**

下面我们来看看 gcDrain：

```go
// gcDrain scans roots and objects in work buffers, blackening grey
// objects until all roots and work buffers have been drained.
//
// If flags&gcDrainUntilPreempt != 0, gcDrain returns when g.preempt
// is set. This implies gcDrainNoBlock.
//
// If flags&gcDrainIdle != 0, gcDrain returns when there is other work
// to do. This implies gcDrainNoBlock.
//
// If flags&gcDrainNoBlock != 0, gcDrain returns as soon as it is
// unable to get more work. Otherwise, it will block until all
// blocking calls are blocked in gcDrain.
//
// If flags&gcDrainFlushBgCredit != 0, gcDrain flushes scan work
// credit to gcController.bgScanCredit every gcCreditSlack units of
// scan work.
//
//go:nowritebarrier
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
	if !writeBarrier.needed {
		throw("gcDrain phase incorrect")
	}
	
	gp := getg().m.curg
	
	// 看到抢占标志时是否要返回
	preemptible := flags&gcDrainUntilPreempt != 0
	
	// 没有任务时是否要等待任务
	blocking := flags&(gcDrainUntilPreempt|gcDrainIdle|gcDrainNoBlock) == 0
	
	// 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
	
	// 是否只执行一定量的工作
	idle := flags&gcDrainIdle != 0
	
	// 记录初始的已扫描数量
	initScanWork := gcw.scanWork
	
	// 扫描idleCheckThreshold(100000)个对象以后检查是否要返回
	// idleCheck is the scan work at which to perform the next
	// idle check with the scheduler.
	idleCheck := initScanWork + idleCheckThreshold
	
	// 如果根对象未扫描完, 则先扫描根对象
	// Drain root marking jobs.
	if work.markrootNext < work.markrootJobs {
		// 如果标记了preemptible, 循环直到被抢占
		for !(preemptible && gp.preempt) {
			// 从根对象扫描队列取出一个值(原子递增)
			job := atomic.Xadd(&work.markrootNext, +1) - 1
			if job >= work.markrootJobs {
				break
			}
			// 执行根对象扫描工作
			markroot(gcw, job)
			// 如果是idle模式并且有其他工作, 则返回
			if idle && pollWork() {
				goto done
			}
		}
	}
	
	// 根对象已经在标记队列中, 消费标记队列
	// 如果标记了preemptible, 循环直到被抢占
	// Drain heap marking jobs.
	for !(preemptible && gp.preempt) {
		// 如果全局标记队列为空, 把本地标记队列的一部分工作分过去
		// (如果wbuf2不为空则移动wbuf2过去, 否则移动wbuf1的一半过去)
		// Try to keep work available on the global queue. We used to
		// check if there were waiting workers, but it's better to
		// just keep work available than to make workers wait. In the
		// worst case, we'll do O(log(_WorkbufSize)) unnecessary
		// balances.
		if work.full == 0 {
			gcw.balance()
		}
		
		// 从本地标记队列中获取对象, 获取不到则从全局标记队列获取
		var b uintptr
		if blocking {
			// 阻塞获取
			b = gcw.get()
		} else {
			// 非阻塞获取
			b = gcw.tryGetFast()
			if b == 0 {
				b = gcw.tryGet()
			}
		}
		
		// 获取不到对象, 标记队列已为空, 跳出循环
		if b == 0 {
			// work barrier reached or tryGet failed.
			break
		}
		
		// 扫描获取到的对象
		scanobject(b, gcw)
		
		// 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000)
		// Flush background scan work credit to the global
		// account if we've accumulated enough locally so
		// mutator assists can draw on it.
		if gcw.scanWork >= gcCreditSlack {
			// 把扫描的对象数量添加到全局
			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
			// 减少辅助GC的工作量和唤醒等待中的G
			if flushBgCredit {
				gcFlushBgCredit(gcw.scanWork - initScanWork)
				initScanWork = 0
			}
			idleCheck -= gcw.scanWork
			gcw.scanWork = 0
			
			// 如果是idle模式且达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环
			if idle && idleCheck <= 0 {
				idleCheck += idleCheckThreshold
				if pollWork() {
					break
				}
			}
		}
	}
	
	// In blocking mode, write barriers are not allowed after this
	// point because we must preserve the condition that the work
	// buffers are empty.
	
done:
	// 把扫描的对象数量添加到全局
	// Flush remaining scan work credit.
	if gcw.scanWork > 0 {
		atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
		// 减少辅助GC的工作量和唤醒等待中的G
		if flushBgCredit {
			gcFlushBgCredit(gcw.scanWork - initScanWork)
		}
		gcw.scanWork = 0
	}
}
```

gcDrain 函数在开始的时候，会根据 flags 不同而选择不同的策略。

-   gcDrainUntilPreempt：当 G 被抢占时返回；
-   gcDrainIdle：调用 `runtime.pollWork`，当 P 上包含其他待执行 G 时返回；
-   gcDrainFractional：调用 `runtime.pollFractionalWorkerExit`，当 CPU 的占用率超过 `fractionalUtilizationGoal` 的 20% 时返回；

设置完 check 变量后就可以执行 `runtime.markroot`进行根对象扫描，每次扫描完毕都会调用 check 函数校验是否应该退出标记任务，如果是那么就跳到 done 代码块中退出标记。

完成标记后会获取待执行的任务：

```go
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
 ...
 // 根对象已经在标记队列中, 消费标记队列
 // 一直循环直到被抢占或 STW
 for !(gp.preempt && (preemptible || atomic.Load(&sched.gcwaiting) != 0)) { 
  // 将本地一部分工作放回全局队列中
  if work.full == 0 {
   gcw.balance()
  }
  // 获取任务
  b := gcw.tryGetFast()
  if b == 0 {
   b = gcw.tryGet()
   if b == 0 { 
    wbBufFlush(nil, 0)
    b = gcw.tryGet()
   }
  }
  // 获取不到对象, 标记队列已为空, 跳出循环
  if b == 0 { 
   break
  }
  // 扫描获取到的对象
  scanobject(b, gcw)
 
  // 如果已经扫描了一定数量的对象，gcCreditSlack值是2000
  if gcw.scanWork >= gcCreditSlack {
   // 把扫描的对象数量添加到全局
   atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
   if flushBgCredit {
    // 记录这次扫描的内存字节数用于减少辅助标记的工作量
    gcFlushBgCredit(gcw.scanWork - initScanWork)
    initScanWork = 0
   }
   checkWork -= gcw.scanWork
   gcw.scanWork = 0

   if checkWork <= 0 {
    checkWork += drainCheckThreshold
    if check != nil && check() {
     break
    }
   }
  }
 }

done:
 // 把扫描的对象数量添加到全局
 if gcw.scanWork > 0 {
  atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  if flushBgCredit {
   // 记录这次扫描的内存字节数用于减少辅助标记的工作量
   gcFlushBgCredit(gcw.scanWork - initScanWork)
  }
  gcw.scanWork = 0
 }
}
```

这里在获取缓存队列之前会调用 `runtime.gcWork.balance`，会将 gcWork 缓存一部分工作放回全局队列中，这个方法主要是用来平衡一下不同 P 的负载情况。

然后获取 gcWork 的缓存任务，并将获取到的任务交给 scanobject 执行，该函数会从传入的位置开始扫描，并会给找到的活跃对象上色。`runtime.gcFlushBgCredit` 会记录这次扫描的内存字节数用于减少辅助标记的工作量。

这里我来总结一下 gcWork 出入队情况。gcWork 的出队就是我们上面的 scanobject 方法，会获取到 gcWork 缓存对象并执行，但是同时如果找到活跃对象也会再次的入队到 gcWork 中。

除了 scanobject 以外，写屏障、根对象扫描和栈扫描都会向 gcWork 中增加额外的灰色对象等待处理。

![](https://pic4.zhimg.com/80/v2-5572d3da4853d0dab5e148772f0871f3_720w.webp)

**根标记**

```text
func markroot(gcw *gcWork, i uint32) { 
 baseFlushCache := uint32(fixedRootCount)
 baseData := baseFlushCache + uint32(work.nFlushCacheRoots)
 baseBSS := baseData + uint32(work.nDataRoots)
 baseSpans := baseBSS + uint32(work.nBSSRoots)
 baseStacks := baseSpans + uint32(work.nSpanRoots)
 end := baseStacks + uint32(work.nStackRoots)

  switch {
  // 释放mcache中的所有span, 要求STW
 case baseFlushCache <= i && i < baseData:
  flushmcache(int(i - baseFlushCache)) 
  // 扫描可读写的全局变量
 case baseData <= i && i < baseBSS:
  for _, datap := range activeModules() {
   markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-baseData))
  }
  // 扫描未初始化的全局变量 
 case baseBSS <= i && i < baseSpans:
  for _, datap := range activeModules() {
   markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-baseBSS))
  }
  // 扫描 finalizers 队列
 case i == fixedRootFinalizers:
  for fb := allfin; fb != nil; fb = fb.alllink {
   cnt := uintptr(atomic.Load(&fb.cnt))
   scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], gcw, nil)
  }
  // 释放已中止的 G 的栈
 case i == fixedRootFreeGStacks: 
  systemstack(markrootFreeGStacks)
  // 扫描 MSpan.specials
 case baseSpans <= i && i < baseStacks: 
  markrootSpans(gcw, int(i-baseSpans))
 // 扫描各个 G 的栈
 default: 
  // 获取需要扫描的 G
  var gp *g
  if baseStacks <= i && i < end {
   gp = allgs[i-baseStacks]
  } else {
   throw("markroot: bad index")
  }
 
  // 记录等待开始的时间
  status := readgstatus(gp) // We are not in a scan state
  if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
   gp.waitsince = work.tstart
  }
 
  // 转交给g0进行扫描
  systemstack(func() { 
   userG := getg().m.curg
   selfScan := gp == userG && readgstatus(userG) == _Grunning
   // 如果是扫描自己的，则转换自己的g的状态
   if selfScan {
    casgstatus(userG, _Grunning, _Gwaiting)
    userG.waitreason = waitReasonGarbageCollectionScan
   }
 
   // 挂起 G，让对应的 G 停止运行
   stopped := suspendG(gp)
   if stopped.dead {
    gp.gcscandone = true
    return
   }
   if gp.gcscandone {
    throw("g already scanned")
   }
   // 扫描g的栈
   scanstack(gp, gcw)
   gp.gcscandone = true
   resumeG(stopped)

   if selfScan {
    casgstatus(userG, _Gwaiting, _Grunning)
   }
  })
 }
}
```

看到上面扫描的BSS和Date相关的内存块的时候我也是感到非常的疑惑，我们结合维基百科 Data segment [https://en.wikipedia.org/wiki/Data_segment](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Data_segment) 的解释可以看到：

> The _.data_ segment contains any global or static variables which have a pre-defined value and can be modified.  
> The BSS segment, also known as _uninitialized data_, is usually adjacent to the data segment.  

Data 段通常是提前被初始化的全局变量，BSS 段通常是没有被初始化的数据。

因为涉及到太多缓存、数据段、栈内存的扫，很多位操作和指针操作，相关代码实现比较复杂。下面简单看看 scanblock，scanstack。

**scanblock**

```text
func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork, stk *stackScanState) {
  
 b := b0
 n := n0
 // 遍历扫描的地址
 for i := uintptr(0); i < n; {
  // 找到bitmap中对应的byte
  bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))
  if bits == 0 {
   i += sys.PtrSize * 8
   continue
  }
  // 遍历 byte
  for j := 0; j < 8 && i < n; j++ {
   // 如果该地址包含指针
   if bits&1 != 0 { 
    p := *(*uintptr)(unsafe.Pointer(b + i))
    if p != 0 {
     // 标记在该地址的对象存活, 并把它加到标记队列
     if obj, span, objIndex := findObject(p, b, i); obj != 0 {
      greyobject(obj, b, i, span, gcw, objIndex)
     } else if stk != nil && p >= stk.stack.lo && p < stk.stack.hi {
      stk.putPtr(p, false)
     }
    }
   }
   bits >>= 1
   i += sys.PtrSize
  }
 }
}
```

**scanstack**

```go
func scanstack(gp *g, gcw *gcWork) {
 ...
 // 判断是否可以安全的进行 收缩栈
 if isShrinkStackSafe(gp) {
  // Shrink the stack if not much of it is being used.
  // 收缩栈
  shrinkstack(gp)
 } else {
  // Otherwise, shrink the stack at the next sync safe point.
  // 否则下次安全点再进行收缩栈
  gp.preemptShrink = true
 }

 var state stackScanState
 state.stack = gp.stack
  
 if gp.sched.ctxt != nil {
  scanblock(uintptr(unsafe.Pointer(&gp.sched.ctxt)), sys.PtrSize, &oneptrmask[0], gcw, &state)
 }
 
 scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  scanframeworker(frame, &state, gcw)
  return true
 }
 // 枚举所有调用帧
 gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0)
 // 枚举所有defer的调用帧
 tracebackdefers(gp, scanframe, nil)
 // Find and trace other pointers in defer records.
 // 扫描defer中的代码块
 for d := gp._defer; d != nil; d = d.link {
  ...
 }
 if gp._panic != nil {
  state.putPtr(uintptr(unsafe.Pointer(gp._panic)), false)
 }

 // 扫描并找到所有可达的栈对象
 state.buildIndex()
 for {
  p, conservative := state.getPtr()
  if p == 0 {
   break
  }
  obj := state.findObject(p)
  if obj == nil {
   continue
  }
  t := obj.typ
  // 已被扫描过
  if t == nil {
   continue
  }
  // 标记扫描
  obj.setType(nil) 
  gcdata := t.gcdata
  var s *mspan
  if t.kind&kindGCProg != 0 {
   s = materializeGCProg(t.ptrdata, gcdata)
   gcdata = (*byte)(unsafe.Pointer(s.startAddr))
  }

  b := state.stack.lo + uintptr(obj.off)
  if conservative {
   scanConservative(b, t.ptrdata, gcdata, gcw, &state)
  } else {
   scanblock(b, t.ptrdata, gcdata, gcw, &state)
  }

  if s != nil {
   dematerializeGCProg(s)
  }
 }
 
 for state.head != nil {
  x := state.head
  state.head = x.next
  
  x.nobj = 0
  putempty((*workbuf)(unsafe.Pointer(x)))
 }
 if state.buf != nil || state.cbuf != nil || state.freeBuf != nil {
  throw("remaining pointer buffers")
 }
}
```

**greyobject**

```go
// obj is the start of an object with mark mbits.
// If it isn't already marked, mark it and enqueue into gcw.
// base and off are for debugging only and could be removed.
//go:nowritebarrierrec
func greyobject(obj, base, off uintptr, hbits heapBits, span *mspan, gcw *gcWork, objIndex uintptr) {
	// obj should be start of allocation, and so must be at least pointer-aligned.
	if obj&(sys.PtrSize-1) != 0 {
		throw("greyobject: obj not pointer-aligned")
	}
	mbits := span.markBitsForIndex(objIndex)

	if useCheckmark {
		// checkmark是用于检查是否所有可到达的对象都被正确标记的机制, 仅除错使用
		if !mbits.isMarked() {
			printlock()
			print("runtime:greyobject: checkmarks finds unexpected unmarked object obj=", hex(obj), "\n")
			print("runtime: found obj at *(", hex(base), "+", hex(off), ")\n")

			// Dump the source (base) object
			gcDumpObject("base", base, off)

			// Dump the object
			gcDumpObject("obj", obj, ^uintptr(0))

			getg().m.traceback = 2
			throw("checkmark found unmarked object")
		}
		if hbits.isCheckmarked(span.elemsize) {
			return
		}
		hbits.setCheckmarked(span.elemsize)
		if !hbits.isCheckmarked(span.elemsize) {
			throw("setCheckmarked and isCheckmarked disagree")
		}
	} else {
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
			print("runtime: marking free object ", hex(obj), " found at *(", hex(base), "+", hex(off), ")\n")
			gcDumpObject("base", base, off)
			gcDumpObject("obj", obj, ^uintptr(0))
			getg().m.traceback = 2
			throw("marking free object")
		}

		// 如果对象所在的span中的gcmarkBits对应的bit已经设置为1则可以跳过处理
		// If marked we have nothing to do.
		if mbits.isMarked() {
			return
		}
		
		// 设置对象所在的span中的gcmarkBits对应的bit为1
		// mbits.setMarked() // Avoid extra call overhead with manual inlining.
		atomic.Or8(mbits.bytep, mbits.mask)
		
		// 如果确定对象不包含指针(所在span的类型是noscan), 则不需要把对象放入标记队列
		// If this is a noscan object, fast-track it to black
		// instead of greying it.
		if span.spanclass.noscan() {
			gcw.bytesMarked += uint64(span.elemsize)
			return
		}
	}

	// 把对象放入标记队列
	// 先放入本地标记队列, 失败时把本地标记队列中的部分工作转移到全局标记队列, 再放入本地标记队列
	// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but
	// seems like a nice optimization that can be added back in.
	// There needs to be time between the PREFETCH and the use.
	// Previously we put the obj in an 8 element buffer that is drained at a rate
	// to give the PREFETCH time to do its work.
	// Use of PREFETCHNTA might be more appropriate than PREFETCH
	if !gcw.putFast(obj) {
		gcw.put(obj)
	}
}

```

**对象扫描**

```go
func scanobject(b uintptr, gcw *gcWork) { 
 // 获取 b 的 heapBits 对象
 hbits := heapBitsForAddr(b)
 // 获取 span
 s := spanOfUnchecked(b)
 // span 对应的对象大小
 n := s.elemsize
 if n == 0 {
  throw("scanobject n == 0")
 }
 // 每次最大只扫描128KB
 if n > maxObletBytes {
  // Large object. Break into oblets for better
  // parallelism and lower latency.
  if b == s.base() { 
   if s.spanclass.noscan() {
    // Bypass the whole scan.
    gcw.bytesMarked += uint64(n)
    return
   }
   // 把多于128KB的对象重新放回gcworker中，下次再扫描
   for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
    if !gcw.putFast(oblet) {
     gcw.put(oblet)
    }
   }
  }

  n = s.base() + s.elemsize - b
  if n > maxObletBytes {
   n = maxObletBytes
  }
 }

 var i uintptr
 for i = 0; i < n; i += sys.PtrSize {
  // 获取对应的bit
  // Find bits for this word.
  if i != 0 { 
   hbits = hbits.next()
  } 
  bits := hbits.bits() 
  // 检查scan bit判断是否继续扫描
  if i != 1*sys.PtrSize && bits&bitScan == 0 {
   break // no more pointers in this object
  }
  // 如果不是指针则继续
  if bits&bitPointer == 0 {
   continue // not a pointer
  }
 
  // 取出指针的值
  obj := *(*uintptr)(unsafe.Pointer(b + i))
 
  if obj != 0 && obj-b >= n { 
   // 根据地址值去堆中查找对象
   if obj, span, objIndex := findObject(obj, b, i); obj != 0 {
    // 调用 greyobject 标记对象并把对象放到标记队列中
    greyobject(obj, b, i, span, gcw, objIndex)
   }
  }
 }
 // 统计扫描过的大小和对象数量
 gcw.bytesMarked += uint64(n)
 gcw.scanWork += int64(i)
}
```

### **辅助标记 mutator assists**
为了防止heap增速太快, 在GC执行的过程中如果同时运行的G分配了内存, 那么这个G会被要求辅助GC做一部分的工作.  
在GC的过程中同时运行的G称为"mutator", "mutator assist"机制就是G辅助GC做一部分工作的机制.

辅助GC做的工作有两种类型, 一种是标记(Mark), 另一种是清扫(Sweep).  
辅助标记的触发可以查看上面的mallocgc函数, 触发时G会帮助扫描"工作量"个对象, 工作量的计算公式是:

```go
debtBytes * assistWorkPerByte
```

意思是分配的大小乘以系数assistWorkPerByte, assistWorkPerByte的计算在函数[revise](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L497)中, 公式是:

```go
// 等待扫描的对象数量 = 未扫描的对象数量 - 已扫描的对象数量
scanWorkExpected := int64(memstats.heap_scan) - c.scanWork
if scanWorkExpected < 1000 {
	scanWorkExpected = 1000
}
// 距离触发GC的Heap大小 = 期待触发GC的Heap大小 - 当前的Heap大小
// 注意next_gc的计算跟gc_trigger不一样, next_gc等于heap_marked * (1 + gcpercent / 100)
heapDistance := int64(memstats.next_gc) - int64(atomic.Load64(&memstats.heap_live))
if heapDistance <= 0 {
	heapDistance = 1
}
// 每分配1 byte需要辅助扫描的对象数量 = 等待扫描的对象数量 / 距离触发GC的Heap大小
c.assistWorkPerByte = float64(scanWorkExpected) / float64(heapDistance)
c.assistBytesPerWork = float64(heapDistance) / float64(scanWorkExpected)
```

和辅助标记不一样的是, 辅助清扫申请新span时才会检查, 而辅助标记是每次分配对象时都会检查.  
辅助清扫的触发可以看上面的cacheSpan函数, 触发时G会帮助回收"工作量"页的对象, 工作量的计算公式是:

```go
spanBytes * sweepPagesPerByte // 不完全相同, 具体看deductSweepCredit函数
```

意思是分配的大小乘以系数sweepPagesPerByte, sweepPagesPerByte的计算在函数[gcSetTriggerRatio](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759)中, 公式是:

```go
// 当前的Heap大小
heapLiveBasis := atomic.Load64(&memstats.heap_live)
// 距离触发GC的Heap大小 = 下次触发GC的Heap大小 - 当前的Heap大小
heapDistance := int64(trigger) - int64(heapLiveBasis)
heapDistance -= 1024 * 1024
if heapDistance < _PageSize {
	heapDistance = _PageSize
}
// 已清扫的页数
pagesSwept := atomic.Load64(&mheap_.pagesSwept)
// 未清扫的页数 = 使用中的页数 - 已清扫的页数
sweepDistancePages := int64(mheap_.pagesInUse) - int64(pagesSwept)
if sweepDistancePages <= 0 {
	mheap_.sweepPagesPerByte = 0
} else {
	// 每分配1 byte(的span)需要辅助清扫的页数 = 未清扫的页数 / 距离触发GC的Heap大小
	mheap_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance)
}
```

在分析的一开始也提到了一些关于 mutator assists 的作用，主要是为了防止 heap 增速太快, 在GC 执行的过程中如果同时运行的 G 分配了内存, 那么这个 G 会被要求辅助 GC 做一部分的工作，它遵循一条非常简单并且朴实的原则，**分配多少内存就需要完成多少标记任务**。

mutator assists 的入口是在 `go\src\runtime\malloc.go` 的mallocgc 函数中：

```go
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
 ...
 //判断是否要辅助GC工作
 //gcBlackenEnabled在GC的标记阶段会开启
 var assistG *g
 if gcBlackenEnabled != 0 {
  assistG = getg()
  if assistG.m.curg != nil {
   assistG = assistG.m.curg
  }
        // 减去内存值
  assistG.gcAssistBytes -= int64(size)
	//会按分配的大小判断需要协助GC完成多少工作
  if assistG.gcAssistBytes < 0 {
            // This G is in debt.
   gcAssistAlloc(assistG)
  }
 }
 ...
 return x
}
```

mallocgc 在分配内存的时候每次都会检查 gcAssistBytes 字段是否为负值，这个字段存储了当前 Goroutine 辅助标记的对象字节数。如果为负数，那么会调用 gcAssistAlloc 从全局信用 bgScanCredit 中获取：

```go
func gcAssistAlloc(gp *g) {
  ...
retry:  
 // 计算需要完成的标记任务数量
 debtBytes := -gp.gcAssistBytes
 scanWork := int64(gcController.assistWorkPerByte * float64(debtBytes))
 if scanWork < gcOverAssistWork {
  scanWork = gcOverAssistWork
  debtBytes = int64(gcController.assistBytesPerWork * float64(scanWork))
 }

 // 获取全局辅助标记的字节数
 bgScanCredit := atomic.Loadint64(&gcController.bgScanCredit)
 stolen := int64(0)
 if bgScanCredit > 0 {
  if bgScanCredit < scanWork {
   stolen = bgScanCredit
   gp.gcAssistBytes += 1 + int64(gcController.assistBytesPerWork*float64(stolen))
  } else {
   stolen = scanWork
   gp.gcAssistBytes += debtBytes
  }
  // 全局信用扣除stolen点数
  atomic.Xaddint64(&gcController.bgScanCredit, -stolen) 
  scanWork -= stolen 
  // 减到 0 说明 bgScanCredit 是由足够的信用可以处理 scanWork
  if scanWork == 0 { 
   return
  }
 } 
 // 到这里说明 bgScanCredit 小于 scanWork
 // 需要调用 gcDrainN 完成指定数量的标记任务并返回
 systemstack(func() {
  // 执行标记任务
  gcAssistAlloc1(gp, scanWork) 
 })

 completed := gp.param != nil
 gp.param = nil
 if completed {
  gcMarkDone()
 }

 if gp.gcAssistBytes < 0 { 
  if gp.preempt {
   Gosched()
   goto retry
  }
  // 如果全局信用仍然不足将当前 Goroutine 陷入休眠 
  // 加入全局的辅助标记队列并等待后台标记任务的唤醒
  if !gcParkAssist() {
   goto retry
  } 
 }  
}
```

如果全局信用仍然不足将当前 Goroutine 陷入休眠 ，加入全局的辅助标记队列并等待后台标记任务的唤醒。

扫描内存时调用 gcFlushBgCredit 会负责唤醒辅助标记 Goroutine ：

```go
func gcFlushBgCredit(scanWork int64) {
 // 辅助队列中不存在等待的 Goroutine 
 if work.assistQueue.q.empty() {
  // 当前的信用会直接加到全局信用 bgScanCredit
  atomic.Xaddint64(&gcController.bgScanCredit, scanWork)
  return
 }

 scanBytes := int64(float64(scanWork) * gcController.assistBytesPerWork)

 lock(&work.assistQueue.lock)
 // 如果辅助队列不为空
 for !work.assistQueue.q.empty() && scanBytes > 0 {
  gp := work.assistQueue.q.pop()
  // 唤醒 Goroutine
  if scanBytes+gp.gcAssistBytes >= 0 { 
   scanBytes += gp.gcAssistBytes
   gp.gcAssistBytes = 0 
   ready(gp, 0, false)
  } else { 
   gp.gcAssistBytes += scanBytes
   scanBytes = 0 
   work.assistQueue.q.pushBack(gp)
   break
  }
 }
 // 标记任务量仍然有剩余，这些标记任务都会加入全局信用
 if scanBytes > 0 { 
  scanWork = int64(float64(scanBytes) * gcController.assistWorkPerByte)
  atomic.Xaddint64(&gcController.bgScanCredit, scanWork)
 }
 unlock(&work.assistQueue.lock)
}
```

gcFlushBgCredit 会获取睡眠的辅助队列 Goroutine ，如果当前信用足够，那么就会将辅助 Goroutine 唤醒，如果还有剩余的，那么就会将这些标记任务都会加入全局信用。

总体来说是如下的一套机制：

![](https://pic1.zhimg.com/80/v2-bacfcf2b39c48d2031dbd0bc54cf062c_720w.webp)

### **完成标记**

上面我们在 gcBgMarkWorker 中分析了，在标记完成后会调用 gcMarkDone 执行标记完成操作。
在所有后台标记任务都把标记队列消费完毕时, 会执行[gcMarkDone](https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1345)函数准备进入完成标记阶段(mark termination):  
在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)。
```go
func gcMarkDone() {
 
 semacquire(&work.markDoneSema)

top: 
 // 再次检查任务是否已执行完毕
 if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  semrelease(&work.markDoneSema)
  return
 }
 
 semacquire(&worldsema)
 
 gcMarkDoneFlushed = 0 
 systemstack(func() {
  gp := getg().m.curg 
  casgstatus(gp, _Grunning, _Gwaiting)
  // 遍历所有的 P
  forEachP(func(_p_ *p) {
   // 将 P 对应的write barrier buffer 中的对象加入到 gcWork 中
   wbBufFlush1(_p_)
   // 将 gcWork 中的缓存对象加入到全局队列中
   _p_.gcw.dispose()
   // 表示 gcWork 的数据都已迁移到 全局队列中
   if _p_.gcw.flushedWork {
    atomic.Xadd(&gcMarkDoneFlushed, 1)
    _p_.gcw.flushedWork = false
   } else if debugCachedWork {
    ...
   }
   ...
  })
  casgstatus(gp, _Gwaiting, _Grunning)
 })

 if gcMarkDoneFlushed != 0 {
  if debugCachedWork {
   // Release paused gcWorks.
   atomic.Xadd(&gcWorkPauseGen, 1)
  }
  semrelease(&worldsema)
  goto top
 }
 // 记录完成标记阶段开始的时间和STW开始的时间
 now := nanotime()
 work.tMarkTerm = now
 work.pauseStart = now
 // 禁止G被抢占
 getg().m.preemptoff = "gcing" 
 // STW
 systemstack(stopTheWorldWithSema) 
 ...   
 // 禁止辅助GC和后台标记任务的运行
 atomic.Store(&gcBlackenEnabled, 0) 
 // 唤醒所有因为辅助GC而休眠的G
 gcWakeAllAssists() 
 semrelease(&work.markDoneSema) 
 schedEnableUser(true) 
 // 计算下一次触发gc需要的heap大小
 nextTriggerRatio := gcController.endCycle() 
 // 执行标记终止
 gcMarkTermination(nextTriggerRatio)
}
```

gcMarkDone 会调用 forEachP 函数遍历所有的 P ，并将对应 P 中的 gcWork 中的任务移动到全局队列中，如果 gcWork 中有任务那么会将 gcMarkDoneFlushed 加1，遍历完所有的 P 之后会判断如果 gcMarkDoneFlushed 不为0，那么跳转到 top 标记位继续循环执行，直到本地队列中没有任务为止。

接下来会关将 gcBlackenEnabled 设置为0，表示关闭辅助标记协程以及后台标记；唤醒被阻塞的辅助标记协程；调用 schedEnableUser 恢复用户 Goroutine 的调度；需要注意的是，目前处在 STW 阶段，所以被唤醒的 Goroutine 不会立马执行，会等到 STW 结束后才执行。

最后调用 gcMarkTermination 执行标记终止。

### **标记终止**

```go
func gcMarkTermination(nextTriggerRatio float64) {
	// World is stopped.
	// Start marktermination which includes enabling the write barrier.
	// 禁止辅助GC和后台标记任务的运行
	atomic.Store(&gcBlackenEnabled, 0)
	
	// 重新允许本地标记队列(下次GC使用)
	gcBlackenPromptly = false
	
	// 设置当前GC阶段到完成标记阶段, 并启用写屏障
	setGCPhase(_GCmarktermination)

	// 记录开始时间
	work.heap1 = memstats.heap_live
	startTime := nanotime()

	// 禁止G被抢占
	mp := acquirem()
	mp.preemptoff = "gcing"
	_g_ := getg()
	_g_.m.traceback = 2
	
	// 设置G的状态为等待中这样它的栈可以被扫描
	gp := _g_.m.curg
	casgstatus(gp, _Grunning, _Gwaiting)
	gp.waitreason = "garbage collection"

	// 切换到g0运行
	// Run gc on the g0 stack. We do this so that the g stack
	// we're currently running on will no longer change. Cuts
	// the root set down a bit (g0 stacks are not scanned, and
	// we don't need to scan gc's internal state).  We also
	// need to switch to g0 so we can shrink the stack.
	systemstack(func() {
		// 开始STW中的标记
		gcMark(startTime)
		
		// 必须立刻返回, 因为外面的G的栈有可能被移动, 不能在这之后访问外面的变量
		// Must return immediately.
		// The outer function's stack may have moved
		// during gcMark (it shrinks stacks, including the
		// outer function's stack), so we must not refer
		// to any of its variables. Return back to the
		// non-system stack to pick up the new addresses
		// before continuing.
	})

	// 重新切换到g0运行
	systemstack(func() {
		work.heap2 = work.bytesMarked
		
		// 如果启用了checkmark则执行检查, 检查是否所有可到达的对象都有标记
		if debug.gccheckmark > 0 {
			// Run a full stop-the-world mark using checkmark bits,
			// to check that we didn't forget to mark anything during
			// the concurrent mark process.
			gcResetMarkState()
			initCheckmarks()
			gcMark(startTime)
			clearCheckmarks()
		}

		// 设置当前GC阶段到关闭, 并禁用写屏障
		// marking is complete so we can turn the write barrier off
		setGCPhase(_GCoff)
		
		// 唤醒后台清扫任务, 将在STW结束后开始运行
		gcSweep(work.mode)

		// 除错用
		if debug.gctrace > 1 {
			startTime = nanotime()
			// The g stacks have been scanned so
			// they have gcscanvalid==true and gcworkdone==true.
			// Reset these so that all stacks will be rescanned.
			gcResetMarkState()
			finishsweep_m()

			// Still in STW but gcphase is _GCoff, reset to _GCmarktermination
			// At this point all objects will be found during the gcMark which
			// does a complete STW mark and object scan.
			setGCPhase(_GCmarktermination)
			gcMark(startTime)
			setGCPhase(_GCoff) // marking is done, turn off wb.
			gcSweep(work.mode)
		}
	})

	// 设置G的状态为运行中
	_g_.m.traceback = 0
	casgstatus(gp, _Gwaiting, _Grunning)

	// 跟踪处理
	if trace.enabled {
		traceGCDone()
	}

	// all done
	mp.preemptoff = ""

	if gcphase != _GCoff {
		throw("gc done but gcphase != _GCoff")
	}

	// 更新下一次触发gc需要的heap大小(gc_trigger)
	// Update GC trigger and pacing for the next cycle.
	gcSetTriggerRatio(nextTriggerRatio)

	// 更新用时记录
	// Update timing memstats
	now := nanotime()
	sec, nsec, _ := time_now()
	unixNow := sec*1e9 + int64(nsec)
	work.pauseNS += now - work.pauseStart
	work.tEnd = now
	atomic.Store64(&memstats.last_gc_unix, uint64(unixNow)) // must be Unix time to make sense to user
	atomic.Store64(&memstats.last_gc_nanotime, uint64(now)) // monotonic time for us
	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)
	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)
	memstats.pause_total_ns += uint64(work.pauseNS)

	// 更新所用cpu记录
	// Update work.totaltime.
	sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)
	// We report idle marking time below, but omit it from the
	// overall utilization here since it's "free".
	markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime
	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)
	cycleCpu := sweepTermCpu + markCpu + markTermCpu
	work.totaltime += cycleCpu

	// Compute overall GC CPU utilization.
	totalCpu := sched.totaltime + (now-sched.procresizetime)*int64(gomaxprocs)
	memstats.gc_cpu_fraction = float64(work.totaltime) / float64(totalCpu)

	// 重置清扫状态
	// Reset sweep state.
	sweep.nbgsweep = 0
	sweep.npausesweep = 0

	// 统计强制开始GC的次数
	if work.userForced {
		memstats.numforcedgc++
	}

	// 统计执行GC的次数然后唤醒等待清扫的G
	// Bump GC cycle count and wake goroutines waiting on sweep.
	lock(&work.sweepWaiters.lock)
	memstats.numgc++
	injectglist(work.sweepWaiters.head.ptr())
	work.sweepWaiters.head = 0
	unlock(&work.sweepWaiters.lock)

	// 性能统计用
	// Finish the current heap profiling cycle and start a new
	// heap profiling cycle. We do this before starting the world
	// so events don't leak into the wrong cycle.
	mProf_NextCycle()

	// 重新启动世界
	systemstack(startTheWorldWithSema)

	// !!!!!!!!!!!!!!!
	// 世界已重新启动...
	// !!!!!!!!!!!!!!!

	// 性能统计用
	// Flush the heap profile so we can start a new cycle next GC.
	// This is relatively expensive, so we don't do it with the
	// world stopped.
	mProf_Flush()

	// 移动标记队列使用的缓冲区到自由列表, 使得它们可以被回收
	// Prepare workbufs for freeing by the sweeper. We do this
	// asynchronously because it can take non-trivial time.
	prepareFreeWorkbufs()

	// 释放未使用的栈
	// Free stack spans. This must be done between GC cycles.
	systemstack(freeStackSpans)

	// 除错用
	// Print gctrace before dropping worldsema. As soon as we drop
	// worldsema another cycle could start and smash the stats
	// we're trying to print.
	if debug.gctrace > 0 {
		util := int(memstats.gc_cpu_fraction * 100)

		var sbuf [24]byte
		printlock()
		print("gc ", memstats.numgc,
			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",
			util, "%: ")
		prev := work.tSweepTerm
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
			if i != 0 {
				print("+")
			}
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
			prev = ns
		}
		print(" ms clock, ")
		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {
			if i == 2 || i == 3 {
				// Separate mark time components with /.
				print("/")
			} else if i != 0 {
				print("+")
			}
			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))
		}
		print(" ms cpu, ",
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
			work.heapGoal>>20, " MB goal, ",
			work.maxprocs, " P")
		if work.userForced {
			print(" (forced)")
		}
		print("\n")
		printunlock()
	}

	semrelease(&worldsema)
	// Careful: another GC cycle may start now.

	// 重新允许当前的G被抢占
	releasem(mp)
	mp = nil

	// 如果是并行GC, 让当前M继续运行(会回到gcBgMarkWorker然后休眠)
	// 如果不是并行GC, 则让当前M开始调度
	// now that gc is done, kick off finalizer thread if needed
	if !concurrentSweep {
		// give the queued finalizers, if any, a chance to run
		Gosched()
	}
}

```

gcMarkTermination 主要是做一些确认工作以及统计工作。进入到这个方法首先会将 GC 阶段设置到 `_GCmarktermination`，然后调用 gcMark 方法确认是否所有的 GC 标记工作已经完成。接着将 GC 阶段设置到 `_GCoff`，调用 gcSweep 开始清理工作。接着就是省略的数据统计相关的代码，包括正在使用的内存大小、GC 时间、CPU 利用率等。最后做一些确认工作，如确保每个 P 的 mcache 都被 flush ，栈都释放了，workbuf 都转移到 free list 以便回收等。

### **后台清扫**

```go
func gcSweep(mode gcMode) {
 if gcphase != _GCoff {
  throw("gcSweep being done but phase is not GCoff")
 }
 lock(&mheap_.lock)
 mheap_.sweepgen += 2
 // 重置标记位
 mheap_.sweepdone = 0
 ...
 mheap_.pagesSwept = 0
 mheap_.sweepArenas = mheap_.allArenas
 mheap_.reclaimIndex = 0
 mheap_.reclaimCredit = 0
 unlock(&mheap_.lock)

 if go115NewMCentralImpl {
  sweep.centralIndex.clear()
 }
 // 如果非并行GC 
 if !_ConcurrentSweep || mode == gcForceBlockMode {
  ...
  return
 }

 // 唤醒后台清扫任务
 lock(&sweep.lock)
 if sweep.parked {
  sweep.parked = false
  ready(sweep.g, 0, true)
 }
 unlock(&sweep.lock)
}
```

gcSweep 主要做的是重置清理阶段的相关状态，然后唤醒 sweep 清扫 Goroutine 。后台清扫任务是在初始化 main Goroutine 的时候调用 bgsweep 设置的：

**gcenable**

```text
func gcenable() {
 // Kick off sweeping and scavenging.
 c := make(chan int, 2)
    // 设置异步清扫
 go bgsweep(c) 
 <-c 
}
```

**bgsweep**

```text
func bgsweep(c chan int) {
 // 设置清扫 Goroutine 
 sweep.g = getg()
 // 等待唤醒 
 lockInit(&sweep.lock, lockRankSweep)
 lock(&sweep.lock)
 sweep.parked = true
 c <- 1
 goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1)

 // 循环清扫
 for {
  // 清扫一个span, 然后进入调度
  for sweepone() != ^uintptr(0) {
   sweep.nbgsweep++
   Gosched()
  }
  // 释放一些未使用的标记队列缓冲区到heap
  for freeSomeWbufs(true) {
   Gosched()
  }
  lock(&sweep.lock)
  // 判断 sweepdone 标志位是否等于 0
  // 如果清扫未完成则继续循环
  if !isSweepDone() { 
   unlock(&sweep.lock)
   continue
  }
  // 否则让后台清扫任务进入休眠
  sweep.parked = true
  goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1)
 }
}
```

bgsweep 的清扫任务实际上是由 sweepone 进行的，它会在堆内存中查找待清理的 span，并且会返回清扫了多少 page 到 heap 中，返回 `^uintptr(0)`表示没有东西需要清扫：

```go
func sweepone() uintptr {
 _g_ := getg()
 sweepRatio := mheap_.sweepPagesPerByte // For debugging 
 _g_.m.locks++
 // 校验是否清扫已完成
 if atomic.Load(&mheap_.sweepdone) != 0 {
  _g_.m.locks--
  return ^uintptr(0)
 }
 atomic.Xadd(&mheap_.sweepers, +1)

 //查找一个 span 并释放
 var s *mspan
 sg := mheap_.sweepgen
 for {
  if go115NewMCentralImpl {
   s = mheap_.nextSpanForSweep()
  } else {
   s = mheap_.sweepSpans[1-sg/2%2].pop()
  }
  if s == nil {
   atomic.Store(&mheap_.sweepdone, 1)
   break
  }
  if state := s.state.get(); state != mSpanInUse { 
   continue
  }
  // span 的 sweepgen 等于 mheap.sweepgen - 2，那么意味着当前单元需要清理
  if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
   break
  }
 }

 // 清理 span
 npages := ^uintptr(0)
 if s != nil {
  npages = s.npages
  // 回收内存
  if s.sweep(false) { 
   atomic.Xadduintptr(&mheap_.reclaimCredit, npages)
  } else {
    
   npages = 0
  }
 } 
 _g_.m.locks--
 return npages
}
```

在查找 span 的时候会通过 state 状态以及 sweepgen 是否等于 `mheap.sweepgen - 2` 来判断是否需要清扫该 span。最终会通过 `mspan.sweep` 来进行清扫。

下面简单看一下 sweep的实现：

```go
func (s *mspan) sweep(preserve bool) bool {
 if !go115NewMCentralImpl {
  return s.oldSweep(preserve)
 } 
 _g_ := getg() 
 sweepgen := mheap_.sweepgen
 // 统计已清理的页数
 atomic.Xadd64(&mheap_.pagesSwept, int64(s.npages))

 spc := s.spanclass
 size := s.elemsize

 c := _g_.m.p.ptr().mcache  
 ...
 // 计算释放的对象数量 
 nalloc := uint16(s.countAlloc())
 nfreed := s.allocCount - nalloc
  
 s.allocCount = nalloc
 s.freeindex = 0 // reset allocation index to start of span.
   
 s.allocBits = s.gcmarkBits
 s.gcmarkBits = newMarkBits(s.nelems)
 
 s.refillAllocCache(0) 
 // 设置 span.sweepgen 和 mheap.sweepgen 相等
 atomic.Store(&s.sweepgen, sweepgen)

 if spc.sizeclass() != 0 {
  // 处理小对象的回收
  // Handle spans for small objects.
  if nfreed > 0 { 
   s.needzero = 1
   c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  }
  if !preserve { 
   if nalloc == 0 { 
    // 直接释放 span 到堆中
    mheap_.freeSpan(s)
    return true
   } 
   // 将 span 释放到 mcentral 中
   if uintptr(nalloc) == s.nelems {
    mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)
   } else {
    mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)
   }
  }
 } else if !preserve { 
  // 处理大对象的回收
  if nfreed != 0 {
   // Free large object span to heap. 
   if debug.efence > 0 {
    s.limit = 0 // prevent mlookup from finding this span
    sysFault(unsafe.Pointer(s.base()), size)
   } else {
    // 直接释放 span 到堆中
    mheap_.freeSpan(s)
   }
   c.local_nlargefree++
   c.local_largefree += size
   return true
  }

  // Add a large span directly onto the full+swept list.
  mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)
 }
 return false
}
```

## **总结**

这篇文章和内存分配、循环调度的关联关系非常的大，所以必须要弄懂前两篇才能理解 GC 的原理。


# Reference
https://zhuanlan.zhihu.com/p/359582221
https://www.cnblogs.com/zkweb/p/7880099.html





