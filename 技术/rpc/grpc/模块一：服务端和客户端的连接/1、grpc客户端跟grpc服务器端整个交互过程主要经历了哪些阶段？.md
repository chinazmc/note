---
sr-due: 2023-01-10
sr-interval: 1
sr-ease: 230
---

#grpc  #note 


在阅读grpc-go源码前，我们先从整体上简单了解一下:
grpc-go框架中grpc客户端跟grpc服务器端整个的交互过程，都经历了哪些过程；
在后面的章节中，我们会对每个过程进行详细的分析；
在grpc-go框架中grpc客户端跟grpc服务器端整个交互主要经历以下阶段：  
grpc客户端跟grpc服务器端整体交互过程，如下图所示：

![grpc客户端跟grpc服务器端整个交互过程大概经历了哪些阶段](https://img-blog.csdnimg.cn/20210511094242134.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1ODI5MjI=,size_16,color_FFFFFF,t_70#pic_center)

-   1、rpc链接建立阶段
    
    -   建立tcp链接阶段
        -   用户设置链接参数，如拦截器设置，链接地址设置等
        -   解析器根据链接地址来获取后端对应的grpc服务器地址列表
        -   平衡器根据grpc服务器地址列表来建立tcp链接
    -   帧交互阶段
        -   grpc服务器端需要自己能够发送的帧大小、窗口大小等信息发送给客户端，
        -   客户端接收到这些信息后，会更新本地的帧大小，窗口大小等信息
        -   PRI校验
-   2、rpc请求阶段
    
    -   客户端将请求服务的名称，方法名称、超时时间等信息封装到头帧里，发送给服务器端；
    -   这样服务器端接收到头帧后，就可以解析出客户端请求的方法名称了，如Greeter服务下的SayHello方法名称了
    -   客户端需要将SayHello方法的具体参数值，进行序列化，压缩后，封装成数据帧发送服务器端
    -   服务器端接收到数据帧后，进行解压，反序列化操作后，就得到了请求方法的具体参数值了，如&pb.HelloRequest{Name: name}
    -   服务器端此时已经知道了客户端请求的方法名称，以及该方法名称的具体参数值了，
    -   服务器端开始具体执行方法，如真正执行SayHello方法了；执行完成后，
    -   服务器端创建头帧，将执行的状态信息发送给客户端，如grpc-status, 状态码200
    -   客户端开始接收服务器端的发送的头帧
    -   服务器端将执行结果，进行序列化、压缩后，封装成数据帧，发送给客户端
    -   客户端接收到服务器端反馈的数据帧后，进行解压，反序列化后，，就可以得到SayHello方法的具体执行结果了。

简单总结一下，

rpc链接，其实就是干了四件事:

-   第一，确定grpc服务器端的地址列表，有哪些；
-   第二，如何向grpc服务器端发起链接，是链接一个grpc服务器端，还是全部连接，还是选择负载低的grpc服务器进行链接，
-   第三，调用golang原生的net包，进行tcp链接；
-   第四，进行http2帧的交互过程，如接下来传输的帧的大小是多少，窗口大小是多少等

rpc请求，干了哪些事呢？

-   第一，通过头帧，将客户端请求方法的服务名称，方法名称等信息传输给服务器端；如服务名称为helloworld.Greeter，方法名称为SayHello
-   第二，通过数据帧，客户端将请求方法的参数值发送给服务器端，
-   第三，到目前为止，服务器端就知道客户端要执行的哪个服务下的哪个方法了，并且也知道该方法的具体参数值了；就可以具体执行了
-   第四，服务器端，将具体的执行结果，封装成数据帧，再反馈客户端，这样客户端就获得了最终的执行结果，也就是实现了在本地调用了远程服务中的某个方法，或者说不同内存空间的方法调用

在这里我们只需要简单了解一下grpc客户端跟grpc服务器端交互的整体流程即可。

详细流程，会在后面的章节中，慢慢介绍的。
