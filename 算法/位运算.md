#review/first_101_算法 

```java
//剑指 Offer 65. 不用加减乘除做加法  
//        写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。  
//        示例:  
//        输入: a = 1, b = 1  
//        输出: 2  
//        提示：  
//        a, b 均可能是负数或 0  
//        结果不会溢出 32 位整数
```
?
```java
//    （和 s ）==（非进位和 n ）++（进位 c ）。即可将 s=a+b 转化为：  
//    s=a+b⇒s=n+c  
//    循环求 n 和 c ，直至进位c=0 ；此时s=n,返回 n 即可。  
//    复杂度分析：  
//    时间复杂度 O(1) ： 最差情况下（例如 a= 0x7fffffff ,b=1 时），需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。  
//    空间复杂度 O(1) ： 使用常数大小的额外空间。  
    public int add(int a, int b) {  
        while(b != 0) { // 当进位为 0 时跳出  
            int c = (a & b) << 1;  // c = 进位  
            a ^= b; // a = 非进位和  
            b = c; // b = 进位  
        }  
        return a;  
    }
```

```java
//剑指 Offer 15. 二进制中1的个数  
//        编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。  
//        提示：  
//        请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。  
//        在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。  
//  
//        示例 1：  
//        输入：n = 11 (控制台输入 00000000000000000000000000001011)  
//        输出：3  
//        解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。  
//        示例 2：  
//        输入：n = 128 (控制台输入 00000000000000000000000010000000)  
//        输出：1  
//        解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。  
//        示例 3：  
//        输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）  
//        输出：31  
//        解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。  
//        提示：  
//        输入必须是长度为 32 的 二进制串 。
```
?
```java
public class HammingWeight {  
//    方法一：逐位判断  
//    根据 与运算 定义，设二进制数字 n ，则有：  
//    若 n&1=0 ，则 n 二进制 最右一位 为 0 ；  
//    若 n&1=1 ，则 n 二进制 最右一位 为 1 。  
//    根据以上特点，考虑以下 循环判断 ：  
//    判断 n 最右一位是否为 1 ，根据结果计数。  
//    将 n 右移一位（本题要求把数字 n 看作无符号数，因此使用 无符号右移 操作）。  
//  
//    复杂度分析：  
//    时间复杂度 O(log_2 n)： 此算法循环内部仅有 移位、与、加 等基本运算，占用 O(1) ；  
//    逐位判断需循环 log2n次，其中 log_2 n代表数字 n 最高位 1 的所在位数（例如 log_2 4 = 2, log_2 16 = 4。  
//    空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。  
    public int hammingWeight(int n) {  
        int res = 0;  
        while(n != 0) {  
            res += n & 1;  
            n >>>= 1;  
        }  
        return res;  
    }  
  
//    方法二：巧用 n&(n−1)  
//            (n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。  
//            n&(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。  
//    复杂度分析：  
//    时间复杂度 O(M) ： n&(n−1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。  
//    空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。  
    public int hammingWeight1(int n) {  
        int res = 0;  
        while(n != 0) {  
            res++;  
            n &= n - 1;  
        }  
        return res;  
    }  
  
}
```
<!--SR:!2022-08-26,25,230-->

```java
//剑指 Offer 56 - I. 数组中数字出现的次数  
//        一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。  
//        示例 1：  
//        输入：nums = [4,1,4,6]  
//        输出：[1,6] 或 [6,1]  
//        示例 2：  
//        输入：nums = [1,2,10,4,1,4,3,3]  
//        输出：[2,10] 或 [10,2]
```
?
```java
//    异或运算有个重要的性质，两个相同数字异或为 0 ，即对于任意整数 a 有 a⊕a=0 。因此，  
//    若将 nums 中所有数字执行异或运算，留下的结果则为 出现一次的数字 x  
//    复杂度分析：  
//    时间复杂度 O(N) ： 线性遍历 nums 使用 O(N) 时间，遍历 x⊕y 二进制位使用 O(32)=O(1) 时间。  
//    空间复杂度 O(1) ： 辅助变量 a , b , x , y 使用常数大小额外空间。  
  
    public int[] singleNumbers(int[] nums) {  
        int x = 0, y = 0, n = 0, m = 1;  
        for(int num : nums)               // 1. 遍历异或  
            n ^= num;  
        while((n & m) == 0)               // 2. 循环左移，计算 m  
            m <<= 1;  
        for(int num: nums) {              // 3. 遍历 nums 分组  
            if((num & m) != 0) x ^= num;  // 4. 当 num & m != 0 因为是异或的，所以最后剩下的这两个数肯定二进制位肯定不一致  
            else y ^= num;                // 4. 当 num & m == 0  
        }  
        return new int[] {x, y};          // 5. 返回出现一次的数字  
    }
```

```java
//剑指 Offer 56 - II. 数组中数字出现的次数 II  
//        在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。  
//        示例 1：  
//        输入：nums = [3,4,3,3]  
//        输出：4  
//        示例 2：  
//        输入：nums = [9,1,7,9,7,9,7]  
//        输出：1  
//        限制：  
//        1 <= nums.length <= 10000  
//        1 <= nums[i] < 2^31
```
?
```java
//    如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 33 的倍数。  
//    因此，统计所有数字的各二进制位中 11 的出现次数，并对 33 求余，结果则为只出现一次的数字  
//    复杂度分析：  
//    时间复杂度 O(N) ： 其中 N 位数组 nums 的长度；遍历数组占用 O(N) ，每轮中的常数个位运算操作占用 O(1) 。  
//    空间复杂度 O(1) ： 数组 counts 长度恒为 32 ，占用常数大小的额外空间。  
    public int singleNumber(int[] nums) {  
        int[] counts = new int[32];  
        for(int num : nums) {  
            for(int j = 0; j < 32; j++) {  
                counts[j] += num & 1;  
                num >>>= 1;  
            }  
        }  
        int res = 0, m = 3;  
        for(int i = 0; i < 32; i++) {  
            res <<= 1;  
            res |= counts[31 - i] % m;  
        }  
        return res;  
    }
```