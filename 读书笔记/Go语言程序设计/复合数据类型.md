#集合  #数组 #slice

# slice
slice表示一个拥有相同类型元素的可变长度的序列。slice通常写成[]T，其中元素的类型都是T；

Go把数组和其他的类型都看成值传递，而在其他的语言，数据是隐形地使用引用传递

slice是一种轻量级的数据结构，可以用来访问数组的部分或者全部的元素，而这个数组称为slice的底层数组。slice有三个属性：指针、长度和容量。指针指向数组的第一个可以从slice中访问的元素，这个元素并不一定是数组的第一个元素。长度是指slice中的元素个数，它不能超过slice的容量。容量的大小通常是从slice的起始元素到底层数组的最后一个元素间元素的个数。

如果slice的引用超过了被引用对象的容量，即cap(s),那么会导致程序宕机；但是如果slice的引用超出了被引用对象的长度，即len(s),那么最终slice会比原slice长。

![[Pasted image 20220210192812.png]]

和数组不同的是，slice无法做比较，因此不能用 == 来测试两个slice是否拥有相同的元素。
为什么slice比较不可以直接使用== 操作符做比较？
1、首先，和数组元素不同，slice的元素是非直接的，有可能slice可以包含它自身。虽然有办法处理这种特殊的情况，但没有一种方法是简单、高效和直观的。
2、slice的元素不是直接的，所以如果底层数组元素改变，同一个slice在不同的时间会拥有不同的元素。由于散列表（例如Go的map类型）仅对元素的键做浅拷贝，这就要求散列表中的键在散列表的整个生命周期内必须保持不变。因为slice需要深度比较，所以就不能用slice作为map的键。![[Pasted image 20220210193641.png]]

## append函数

![[Pasted image 20220210194439.png]]

# map
map元素不是一个变量，不可以获取它的地址，比如这样是不对：
__ = &ages["bob"]  //编译错误，无法获取map元素的地址
我们无法获取map元素的地址的一个原因是map的增长可能会导致已有元素被重新散列到新的存储地址，这样就可能使得获取得地址无效。


