#es 

本章分析单个节点的启动和关闭流程。看看进程是如何解析配置、检查环境、初始化内部模块的，以及在节点被“kill”的时候是如何处理的。

# 启动流程
做了什么总体来说，节点启动流程的任务是做下面几类工作：· 解析配置，包括配置文件和命令行参数。
· 检查外部环境和内部环境，例如，JVM版本、操作系统内核参数等。
· 初始化内部资源，创建内部模块，初始化探测器。
· 启动各个子模块和keepalive线程。

# 启动流程分析
## 启动脚本
## 解析命令行参数和配置文件
## 加载安全配置
## 检查内部环境
## 检测外部环境
### 内存锁定检查
ES允许进程只使用物理内存，避免使用交换分区。实际上，我们建议生产环境中直接禁用操作系统的交换分区。现在已经不是因为内存不足而需要交换到硬盘上的时代，对于服务器来说，当内存真的用完时，交换到硬盘上会引起更多问题。
开启 bootstrap.memory_lock 选项来让 ES 锁定内存，在开启本项检查，而锁定失败的情况下，本项检查执行失败。
### 最大线程数检查
### 最大虚拟内存检查
### 最大文件大小检查
### 虚拟内存区域最大数量检查
### JVM Client模式检查
### 串行收集检查
### 系统调用过滤器检查
### OnError与OnOutOfMemoryError检查
### Early-access检查
### G1GC检查

## 启动内部模块
环境检查完毕，开始启动各子模块。子模块在Node类中创建，启动它们时调用各自的start（）方法，例如：
discovery.start（）；
clusterService.start（）；
nodeConnectionsService.start（）；
子模块的start方法基本就是初始化内部数据、创建线程池、启动线程池等操作。

## 启动keepalive线程
调用keepAliveThread.start（）方法启动keepalive线程，线程本身不做具体的工作。主线程执行完启动流程后会退出，keepalive线程是唯一的用户线程，作用是保持进程运行。在Java程序中，至少要有一个用户线程。当用户线程数为零时退出进程。

# 节点关闭流程
现在我们探讨一下单个节点的关闭流程。设想当我们为 ES 集群更新配置、升级版本时，需要通过“kill”ES进程来关闭节点。但是kill操作是否安全？如果此时节点有正在执行的读写操作会有什么影响？如果节点是Master该如何处理？关闭流程是怎么实现的？kill节点都会带来哪些风险？
答案是：ES进程会捕获SIGTERM信号（kill命令默认信号）进行处理，调用各模块的stop方法，让它们有机会停止服务，安全退出。
进程重启期间，如果主节点被关闭，则集群会重新选主，在这期间，集群有一个短暂的无主状态。如果集群中的主节点是单独部署的，则新主当选后，可以跳过gateway和recovery流程，否则新主需要重新分配旧主所持有的分片：提升其他副本为主分片，以及分配新的副分片。
如果数据节点被关闭，则读写请求的TCP连接也会因此关闭，对客户端来说写操作执行失败。但写流程已经到达Engine环节的会正常写完，只是客户端无法感知结果。此时客户端重试，如果使用自动生成ID，则数据内容会重复。
综合来说，滚动升级产生的影响是中断当前写请求，以及主节点重启可能引起的分片分配过程。提升新的主分片一般都比较快，因此对集群的写入可用性影响不大。

当索引部分主分片未分配时，使用自动生成ID的情况下，如果持续写入，则客户端对失败重试可能会成功（请求到达已分配成功的主分片），但是会在不同的分片之间产生数据倾斜，倾斜程度视期间数量而定。

# 关闭流程分析
在节点启动过程中，Bootstrap#setup 方法中添加了 shutdown hook，当进程收到系统SIGTERM（kill命令默认信号）或SIGINT信号时，调用Node#close方法，执行节点关闭流程。每个模块的Service中都实现了doStop和doClose，用于处理这个模块的正常关闭流程。节点总的关闭流程位于Node#close，在close方法的实现中，先调用一遍各个模块的doStop，然后再次遍历各个模块执行doClose。
综合来看，关闭顺序大致如下：
· 关闭快照和HTTPServer，不再响应用户REST请求。
· 关闭集群拓扑管理，不再响应ping请求。
· 关闭网络模块，让节点离线。
· 执行各个插件的关闭流程。
· 关闭IndicesService。
最后才关闭IndicesService，是因为这期间需要等待释放的资源最多，时间最长。

# 分片读写过程中执行关闭
下面分别对读和写执行过程中关闭节点进行分析。
写入过程中关闭：线程在写入数据时，会对Engine加写锁。IndicesService的doStop方法对本节点上全部索引并行执行removeIndex，当执行到Engine的flushAndClose（先flush然后关闭Engine），也会对Engine加写锁。由于写入操作已经加了写锁，此时写锁会等待，直到写入执行完毕。因此数据写入过程不会被中断。但是由于网络模块被关闭，客户端的连接会被断开。客户端应当作为失败处理，虽然ES服务端的写流程还在继续。
读取过程中关闭：线程在读取数据时，会对Engine加读锁。flushAndClose时的写锁会等待读取过程执行完毕。但是由于连接被关闭，无法发送给客户端，导致客户端读失败。
节点关闭过程中，IndicesService的doStop对Engine设置了超时，如果flushAndClose一直等待，则CountDownLatch.await默认1天才会继续后面的流程。

# 主分片被关闭
主节点被关闭时，没有想象中的特殊处理，节点正常执行关闭流程，当TransportService模块被关闭后，集群重新选举新Master。因此，滚动重启期间会有一段时间处于无主状态。

# 小结
（1）总体来说，节点启动流程做的就是初始化和检查工作，各个子模块启动后异步地工作，加载本地数据，或者选主、加入集群等，在后面的章节中单独介绍。
（2）节点在关闭时有机会处理未写完的数据，但是写完后可能来不及通知客户端。包括线程池中尚未执行的任务，在一定的超时时间内都有机会执行完。集群健康从Red变为Green的时间主要消耗在维护主副分片的一致性上。我们也可以选择在集群健康为Yellow时就允许客户端写入，但是会牺牲一些数据安全性。

