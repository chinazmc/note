#es 

索引分片数量一般在模板中统一定义，在数据规模比较大的索引中，索引分片数一般也大一些，在笔者的集群中设置为24。同时按天生成新的索引，使用别名关联。但是，并非每天的索引数据量都很大，小数据量的索引同样有较大的分片数。在 ES中，主节点管理分片是很大的工作量，降低集群整体分片数量可以减少recovery时间，减小集群状态的大小。因此，可以使用Shrink API缩小索引分片数。当索引缩小完成后，源索引可以删除。
Shrink API是ES 5.0之后提供的新功能，其可以缩小主分片数量。但其并不对源索引直接进行缩小操作，而是使用与源索引相同的配置创建一个新索引，仅降低分片数。由于添加新文档时使用对分片数量取余获取目的分片的关系，新索引的主分片数必须是源索引主分片数的因数。例如，8个分片可以缩小到4、2、1个分片。
如果源索引的分片数为素数，则目标索引的分片数只能为1。下面举一个例子来分析缩小过程。

# Shrink的工作原理
引用官方手册对Shrink工作过程的描述：
· 以相同配置创建目标索引，但是降低主分片数量。
· 从源索引的Lucene分段创建硬链接到目的索引。如果系统不支持硬链接，那么索引的所有分段都将复制到新索引，将会花费大量时间。
· 对目标索引执行恢复操作，就像一个关闭的索引重新打开时一样。

## 17.3.1 创建新索引
使用旧索引的配置创建新索引，只是减少主分片的数量，所有副本都迁移到同一个节点。显然，创建硬链接时，源文件和目标文件必须在同一台主机。
## 17.3.2 创建硬链接
从源索引到目的索引创建硬链接。如果操作系统不支持硬链接，则复制Lucene分段。
在Linux下通过strace命令跟踪硬链接创建过程：
strace -e trace=file -p {pid}
Linux下的strace命令用于跟踪系统调用，trace=file表示只跟踪与文件操作相关的系统调用，关于该命令的完整使用方式请求可参考man手册。在strace命令的输出结果中，我们能清晰看到内部过程
链接过程：从源索引的shard[0]开始，遍历所有shard，将所有segment链接到目的索引，目的索引的segment从0开始命名，依次递增。
为什么一定要硬链接，不使用软链接？
Linux的文件系统由两部分组成（实际上任何文件系统的基本概念都相似）:inode和block。block用于存储用户数据，inode用于记录元数据，系统通过inode定位唯一的文件。
· 硬链接：文件有相同的inode和block。
· 软链接：文件有独立的inode和block,block内容为目的文件路径名。
那么为什么一定要硬链接过去呢？从本质上来说，我们需要保证Shrink之后，源索引和目的索引是完全独立的，读写和删除都不应该互相影响。如果软链接过去，删除源索引，则目的索引的数据也会被删除，硬链接则不会。满足下面条件时操作系统才真正删除文件：
文件被打开的fd数量为0且硬链接数量为0。使用硬链接，删除源索引，只是将文件的硬链接数量减1，删除源索引和目的索引中的任何一个，都不影响另一个正常读写。

由于使用了硬链接，也因为硬链接的特性带来一些限制：不能交叉文件系统或分区进行硬链接的创建，因为不同分区和文件系统有自己的inode。
不过，既然都是链接，Shrink 完成后，修改源索引，目的索引会变吗？答案是不会。虽然链接到了源分段，Shrink 期间索引只读，目标索引能看到的只有源索引的当前数据，Shrink 完成后，由于Lucene中分段的不变性，“write once”机制保证每个文件都不会被更新。源索引新写入的数据随着refresh会生成新分段，而新分段没有链接，在目标索引中是看不到的。如果源索引进行merge，对源分段执行删除时，只是硬链接数量减1，目标索引仍然不受影响。因此， Shrink完毕后最终的效果就是，两个索引的数据看起来是完全独立的。
经过链接过程之后，主分片已经就绪，副分片还是空的，通过recovery将主分片数据复制到副分片。




