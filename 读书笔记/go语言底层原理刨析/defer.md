#defer

## 参数预计算

defer的另一个特性是参数的预计算，这一特性时常导致开发者在使用defer时犯错。因为在大部分时候，我们记住的都是其延迟执行的特性。参数的预计算指当函数到达defer语句时，延迟调用的参数将立即求值，传递到defer函数中的参数将预先被固定，而不会等到函数执行完成后再传递参数到defer中。如下例所示，defer后的函数需要传递int参数，首先将a赋值为1，接着defer函数的参数传递为a+1，最后，在函数返回前a被赋值为99。那么最后defer函数打印出的b值是多少呢？答案是2。原因是传递到defer的参数是预执行的，因此在执行到defer语句时，执行了a+1并将其保留了起来，直到函数执行完成后才执行defer函数体内的语句。
![[Pasted image 20220213144446.png]]
## defer多次执行与LIFO执行顺序
在函数体内部，可能出现多个defer函数。这些defer函数将按照后入先出（last-infirst-out，LIFO）的顺序执行，这与栈的执行顺序是相同的。

## defer返回值陷阱
除了前面提到的参数预计算，defer还有一种非常容易犯错的场景，涉及与返回值参数结合。如下所示，函数f中有返回值r，return g之后在defer函数中将g赋值为200。
![[Pasted image 20220213145230.png]]
![[Pasted image 20220213145250.png]]
![[Pasted image 20220213145305.png]]

# defer底层原理
在Go 1.14之后，根据不同的场景，实际存在了3种实现defer的方式

## 堆分配
在Go 1.13前，defer全部使用在堆区分配的内存存储，由于本书基于Go 1.14进行讲解，因此本节主要关注Go 1.14后出现堆分配的情况。目前在大部分情况下，堆分配只会在循环结构中出现，例如在for循环结构中。
![[Pasted image 20220213145726.png]]
当defer执行完毕被销毁后，会重新回到局部缓存池中，当局部缓存池容纳了足够的对象时，会将_defer结构体放入全局缓存池。存储在全局和局部缓存池中的对象如果没有被使用，则最终在垃圾回收阶段被销毁。关于垃圾回收的详细知识，参见第19章。
？？？？

## defer遍历调用
正如之前在汇编代码中看到的，当函数正常结束时，其递归调用了runtime.deferreturn函数遍历defer链，并调用存储在defer中的函数。

## Go 1.13栈分配优化

从defer堆分配的过程可以看出，即便有全局和局部缓存池策略，由于涉及堆与栈参数的复制等操作，堆分配仍然比直接调用效率低下。Go 1.13为了解决堆分配的效率问题，对于最多调用一次的defer语义采用了在栈中分配的策略。在Go 1.14中，对于非for循环的结构，有两种方式可以调试defer的栈分配。一种方式是禁止编译器优化（go tool compile-S-N-l stack.go），另一种方式是增加defer的数量到8个以上，无论采用哪种方式，当执行到defer语句时，调用都会变为执行运行时的runtime.deferprocStack函数。在函数的最后，和堆分配一样，仍然插入了runtime.deferreturn函数用于遍历调用链。

## Go 1.14内联优化
虽然Go 1.13中defer的栈策略已经有了比较大的优化，但是与直接的函数调用还是有很大差别。一种容易想到的优化策略是在编译时函数结束时直接调用defer函数，如图10-5所示。这样就可以省去放置到_defer链表和遍历_defer链表的时间。
