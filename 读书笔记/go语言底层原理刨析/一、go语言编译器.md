#编译器 #编译过程  #闭包


# go语言编译器的阶段
如图1-1所示，在经典的编译原理中，一般将编译器分为编译器前端、优化器和编译器后端。这种编译器被称为三阶段编译器（three-phase compiler）。其中，编译器前端主要专注于理解源程序、扫描解析源程序并进行精准的语义表达。编译器的中间阶段（Intermediate Representation，IR）可能有多个，编译器会使用多个IR阶段、多种数据结构表示代码，并在中间阶段对代码进行多次优化。例如，识别冗余代码、识别内存逃逸等。编译器的中间阶段离不开编译器前端记录的细节。编译器后端专注于生成特定目标机器上的程序，这种程序可能是可执行文件，也可能是需要进一步处理的中间形态obj文件、汇编语言等。
![[Pasted image 20220209203042.png]]
Go语言编译器一般缩写为小写的gc（go compiler），需要和大写的GC（垃圾回收）进行区分。Go语言编译器的执行流程可细化为多个阶段，包括词法解析、语法解析、抽象语法树构建、类型检查、变量捕获、函数内联、逃逸分析、闭包重写、遍历函数、SSA生成、机器码生成，如图1-2所示。后面的章节将对这些阶段逐一进行分析。
![[Pasted image 20220209203129.png]]
# 词法分析
在词法解析阶段，Go语言编译器会扫描输入的Go源文件，并将其符号（token）化。例如“+”和“-”操作符会被转换为_IncOp，赋值符号“：=”会被转换为_Define。这些token实质上是用iota声明的整数，定义在syntax/tokens.go中。符号化保留了Go语言中定义的符号，可以识别出错误的拼写。同时，字符串被转换为整数后，在后续的阶段中能够被更加高效地处理。图1-3为一个示例，展现了将表达式a：=b+c（12）符号化之后的情形。代码中声明的标识符、关键字、运算符和分隔符等字符串都可以转化为对应的符号。
![[Pasted image 20220209203252.png]]
# 语法分析
词法解析阶段结束后，需要根据Go语言中指定的语法对符号化后的Go文件进行解析。Go语言采用了标准的自上而下的递归下降（Top-Down Recursive-Descent）算法，以简单高效的方式完成无须回溯的语法扫描，核心算法位于syntax/nodes.go及syntax/parser.go中。图1-4为Go语言编译器对文件进行语法解析的示意图。在一个Go源文件中主要有包导入声明（import）、静态常量（const）、类型声明（type）、变量声明（var）及函数声明。
![[Pasted image 20220209203411.png]]
语法解析丢弃了一些不重要的标识符，例如括号“（”，并将语义存储到了对应的结构体中。语法声明的结构体拥有对应的层次结构，这是构建抽象语法树的基础。图1-5为a：=b+c（12）语句被语法解析后转换为对应的syntax.AssignStmt结构体之后的情形。最顶层的Op操作符为token.Def（：=）。Lhs表达式类型为标识符syntax.Name，值为标识符“a”。Rhs表达式为syntax.Operator加法运算。加法运算左边为标识符“b”，右边为函数调用表达式，类型为CallExpr。其中，函数名c的类型为syntax.Name，参数为常量类型syntax.BasicLit，代表数字12。
![[Pasted image 20220209203548.png]]
# 抽象语法树构建
编译器前端必须构建程序的中间表示形式，以便在编译器中间阶段及后端使用。抽象语法树（Abstract Syntax Tree，AST）是一种常见的树状结构的中间态。

# 类型检查

# 变量捕获
类型检查阶段完成后，Go语言编译器将对抽象语法树进行分析及重构，从而完成一系列优化。变量捕获主要是针对闭包场景而言的，由于闭包函数中可能引用闭包外的变量，因此变量捕获需要明确在闭包中通过值引用或地址引用的方式来捕获变量。下面的例子中有一个闭包函数，在闭包内引入了闭包外的a、b变量，由于变量a在闭包之后进行了其他赋值操作，因此在闭包中，a、b变量的引用方式会有所不同。在闭包中，必须采取地址引用的方式对变量a进行操作，而对变量b的引用将通过直接值传递的方式进行。
![[Pasted image 20220209203925.png]]
在Go语言编译的过程中，可以通过如下方式查看当前程序闭包变量捕获的情况。从输出中可以看出，a采取ref引用传递的方式，而b采取了值传递的方式。assign=true代表变量a在闭包完成后又进行了赋值操作。
![[Pasted image 20220209203953.png]]
# 函数内联
函数内联指将较小的函数直接组合进调用者的函数。这是现代编译器优化的一种核心技术。函数内联的优势在于，可以减少函数调用带来的开销。对于Go语言来说，函数调用的成本在于参数与返回值栈复制、较小的栈寄存器开销以及函数序言部分的检查栈扩容（Go语言中的栈是可以动态扩容的），详见第9章。同时，函数内联是其他编译器优化（例如无效代码消除）的基础。我们可以通过一段简单的程序衡量函数内联带来的效率提升

# 逃逸分析
Go语言能够通过编译时的逃逸分析识别这种问题，自动将该变量放置到堆区，并借助Go运行时的垃圾回收机制自动释放内存。编译器会尽可能地将变量放置到栈中，因为栈中的对象随着函数调用结束会被自动销毁，减轻运行时分配和垃圾回收的负担。
在Go语言中，开发者模糊了栈区与堆区的差别，不管是字符串、数组字面量，还是通过new、make标识符创建的对象，都既可能被分配到栈中，也可能被分配到堆中。分配时，遵循以下两个原则：
◎ 原则1：指向栈上对象的指针不能被存储到堆中
◎ 原则2：指向栈上对象的指针不能超过该栈对象的生命周期
Go语言通过对抽象语法树的静态数据流分析（static data-flowanalysis）来实现逃逸分析，这种方式构建了带权重的有向图。简单的逃逸现象举例如下：
![[Pasted image 20220209204252.png]]
在上例中，变量z为全局变量，是一个指针。在函数中，变量z引用了变量a的地址。如果变量a被分配到栈中，那么最终程序将违背原则2，即变量z超过了变量a的生命周期，因此变量a最终将被分配到堆中。可以通过在编译时加入-m=2标志打印出编译时的逃逸分析信息。如下所示，表明变量a将被放置到堆中。
![[Pasted image 20220209204441.png]]
Go语言在编译时构建了带权重的有向图，其中权重可以表明当前变量引用与解引用的数量。下例为p引用q时的权重，当权重大于0时，代表存在*解引用操作。当权重为-1时，代表存在&引用操作。
![[Pasted image 20220209204518.png]]
并不是权重为-1就一定要逃逸，例如在下例中，虽然z引用了变量a的地址，但是由于变量z并没有超过变量a的声明周期，因此变量a与变量z都不需要逃逸。
![[Pasted image 20220209204551.png]]
为了理解编译器带权重的有向图，再来看一个更加复杂的例子。在该案例中有多次的引用与解引用过程。
![[Pasted image 20220209204615.png]]
最终编译器在逃逸分析中的数据流分析，会被解析成如图1-7所示的带权重的有向图。其中，节点代表变量，边代表变量之间的赋值，箭头代表赋值的方向，边上的数字代表当前赋值的引用或解引用的个数。节点的权重=前一个节点的权重+箭头上的数字，例如节点m的权重为2-1=1，而节点l的权重为1-1=0。
![[Pasted image 20220209204642.png]]
遍历和计算有向权重图的目的是找到权重为-1的节点，例如图1-7中的new（int）节点，它的节点变量地址会被传递到根节点o中，这时还需要考虑逃逸分析的分配原则，o节点为全局变量，不能被分配在栈中，因此，new（int）节点创建的变量会被分配到堆中。

# 闭包重写



# 遍历函数
# SSA生成
遍历函数后，编译器会将抽象语法树转换为下一个重要的中间表示形态，称为SSA（Static Single Assignment，静态单赋值）。SSA被大多数现代的编译器（包括GCC和LLVM）使用，在Go 1.7中被正式引入并替换了之前的编译器后端，用于最终生成更有效的机器码。在SSA生成阶段，每个变量在声明之前都需要被定义，并且，每个变量只会被赋值一次。
SSA生成阶段是编译器进行后续优化的保证，例如常量传播（Constant Propagation）、无效代码清除、消除冗余、强度降低（Strength Reduction）等[4]。
# 机器码生成-汇编器
# 机器码生成-链接
程序可能使用其他程序或程序库（library），正如我们在helloworld程序中使用的fmt package一样，编写的程序必须与这些程序或程序库组合在一起才能执行，链接就是将编写的程序与外部程序组合在一起的过程。链接分为静态链接与动态链接，静态链接的特点是链接器会将程序中使用的所有库程序复制到最后的可执行文件中，而动态链接只会在最后的可执行文件中存储动态链接库的位置，并在运行时调用。因此静态链接更快，并且可移植，它不需要运行它的系统上存在该库，但是它会占用更多的磁盘和内存空间。静态链接发生在编译时的最后一步，动态链接发生在程序加载到内存时。表1-1对比了静态链接与动态链接的区别。


# 总结
Go语言可执行文件的生成离不开编译器所做的复杂工作，如果不理解Go语言的编译器，那么对Go语言的理解是不完整的。编译阶段包括词法解析、语法解析、抽象语法树构建、类型检查、变量捕获、函数内联、逃逸分析、闭包重写、遍历并编译函数、SSA生成、机器码生成。编译器不仅能准确地表达语义，还能对代码进行一定程度的优化。可以看到，Go语言的很多语法检查、语法特性都依赖编译时。理解编译时的基本流程、优化方案及一些调试技巧有助于写出更好的程序。本书的后续章节，还将频繁使用编译器的知识来探究Go语法中的特性。
![[Pasted image 20220209205110.png]]
# 遍历函数
# SSA生成
遍历函数后，编译器会将抽象语法树转换为下一个重要的中间表示形态，称为SSA（Static Single Assignment，静态单赋值）。SSA被大多数现代的编译器（包括GCC和LLVM）使用，在Go 1.7中被正式引入并替换了之前的编译器后端，用于最终生成更有效的机器码。在SSA生成阶段，每个变量在声明之前都需要被定义，并且，每个变量只会被赋值一次。

SSA生成阶段是编译器进行后续优化的保证，例如常量传播（Constant Propagation）、无效代码清除、消除冗余、强度降低（Strength Reduction）等[4]。

# 机器码生成-汇编器
# 机器码生成-链接
程序可能使用其他程序或程序库（library），正如我们在helloworld程序中使用的fmt package一样，编写的程序必须与这些程序或程序库组合在一起才能执行，链接就是将编写的程序与外部程序组合在一起的过程。链接分为静态链接与动态链接，静态链接的特点是链接器会将程序中使用的所有库程序复制到最后的可执行文件中，而动态链接只会在最后的可执行文件中存储动态链接库的位置，并在运行时调用。因此静态链接更快，并且可移植，它不需要运行它的系统上存在该库，但是它会占用更多的磁盘和内存空间。静态链接发生在编译时的最后一步，动态链接发生在程序加载到内存时。表1-1对比了静态链接与动态链接的区别。

![[Pasted image 20220209205608.png]]

Go语言在默认情况下是使用静态链接的，但是在一些特殊情况下，如在使用了CGO（即引用了C代码）时，则会使用操作系统的动态链接库，例如，Go语言的net/http包在默认情况下会使用libpthread与lib c的动态链接库。Go语言也支持在go build编译时通过传递参数来指定要生成的链接库的方式，可以使用go help build命令查看。

# ELF文件解析

# 总结
Go语言可执行文件的生成离不开编译器所做的复杂工作，如果不理解Go语言的编译器，那么对Go语言的理解是不完整的。编译阶段包括词法解析、语法解析、抽象语法树构建、类型检查、变量捕获、函数内联、逃逸分析、闭包重写、遍历并编译函数、SSA生成、机器码生成。编译器不仅能准确地表达语义，还能对代码进行一定程度的优化。可以看到，Go语言的很多语法检查、语法特性都依赖编译时。理解编译时的基本流程、优化方案及一些调试技巧有助于写出更好的程序。本书的后续章节，还将频繁使用编译器的知识来探究Go语法中的特性。
