#协程 #线程

# 对比
## 调度方式
协程是用户态的。协程的管理依赖Go语言运行时的调度器。同时，Go语言中的协程是从属于某一个线程的，协程与线程的对应关系为M：N，即多对多，如图14-4所示。Go语言调度器可以将多个协程调度到一个线程中，一个协程也可能切换到多个线程中执行。
## 上下文切换的速度
协程的速度要快于线程，其原因在于协程切换不用经过操作系统用户态与内核态的切换，并且Go语言中的协程切换只需要保留极少的状态和寄存器变量值（SP/BP/PC），而线程切换会保留额外的寄存器变量值（例如浮点寄存器）。上下文切换的速度受到诸多因素的影响，这里列出一些值得参考的量化指标：线程切换的速度大约为1～2微秒，Go语言中协程切换的速度比它快数倍，为0.2微秒左右[3]。
## 调度策略
线程的调度在大部分时间是抢占式的，操作系统调度器为了均衡每个线程的执行周期，会定时发出中断信号强制执行线程上下文切换。而Go语言中的协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程。这意味着协程可以更好地在规定时间内完成自己的工作，而不会轻易被抢占。当一个协程运行了过长时间时，Go语言调度器才会强制抢占其执行（详见第15章）。
## 栈的大小
线程的栈大小一般是在创建时指定的，为了避免出现栈溢出（Stack Overflow），默认的栈会相对较大（例如2MB），这意味着每创建1000个线程就需要消耗2GB的虚拟内存，大大限制了线程创建的数量（64位的虚拟内存地址空间已经让这种限制变得不太严重）。而Go语言中的协程栈默认为2KB，在实践中，经常会看到成千上万的协程存在。
同时，线程的栈在运行时不能更改，但是Go语言中的协程栈在Go运行时的帮助下会动态检测栈的大小，并动态地进行扩容。因此，在实践中，可以将协程看作轻量的资源。

# 并行和并发
在实际的多核处理场景中，并发与并行常常是同时存在的，即多核在并行地处理多个线程，而单核中的多个线程又在上下文切换中交替执行。由于Go语言中的协程依托于线程，所以即便处理器运行的是同一个线程，在线程内Go语言调度器也会切换多个协程执行，这时协程是并发的。如果多个协程被分配给了不同的线程，而这些线程同时被不同的CPU核心处理，那么这些协程就是并行处理的。因此在多核处理场景下，Go语言的协程是并发与并行同时存在的。

# 主协程和子协程
协程分为主协程与子协程
main函数是一个特殊的协程，当主协程退出时，程序直接退出，这是主协程与其他协程的显著区别，如果其他协程还未执行完成，主协程就直接退出了，那么此时不会有任何输出。

# GMP模型
Go语言中经典的GMP的概念模型生动地概括了线程与协程的关系：Go进程中的众多协程其实依托于线程，借助操作系统将线程调度到CPU执行，从而最终执行协程。在GMP模型中，G代表的是Go语言中的协程（Goroutine），M代表的是实际的线程，而P代表的是Go逻辑处理器（Process），Go语言为了方便协程调度与缓存，抽象出了逻辑处理器。G、M、P之间的对应关系如图14-9所示。在任一时刻，一个P可能在其本地包含多个G，同时，一个P在任一时刻只能绑定一个M。图14-9中没有涵盖的信息是：一个G并不是固定绑定同一个P的，有很多情况（例如P在运行时被销毁）会导致一个P中的G转移到其他的P中。同样的，一个P只能对应一个M，但是具体对应的是哪一个M也是不固定的。一个M可能在某些时候转移到其他的P中执行。随着讲解的深入，后续还会细化这一模型。
![[Pasted image 20220224155228.png]]

# 协程的生命周期与状态转移
**协程并不只有创建和死亡两种状态**。为了便于对协程进行管理，Go语言的调度器将协程分为多种状态，协程的状态与转移如图15-1所示。
![[Pasted image 20220224155322.png]]
◎ _Gidle为协程刚开始创建时的状态，当新创建的协程初始化后，会变为_Gdead状态，_Gdead状态也是协程被销毁时的状态。
◎ _Grunnable表示当前协程在运行队列中，正在等待运行。
◎ _Grunning代表当前协程正在被运行，已经被分配给了逻辑处理器和线程。
◎ _Gwaiting表示当前协程在运行时被锁定，不能执行用户代码。在垃圾回收及channel通信时经常会遇到这种情况。
◎ _Gsyscall代表当前协程正在执行系统调用。
◎ _Gpreempted是Go 1.14新加的状态，代表协程G被强制抢占后的状态。
◎ _Gcopystack代表在进行协程栈扫描时发现需要扩容或缩小协程栈空间，将协程中的栈转移到新栈时的状态。

# 特殊协程g0与协程切换
之前介绍过，一般的协程有main协程与子协程，main协程在整个程序中只有一个。深入Go语言运行时会发现，每个线程中都有一个特殊的协程g0。
协程g0运行在操作系统线程栈上，其作用主要是执行协程调度的一系列运行时代码，而一般的协程无差别地用于执行用户代码。很显然，执行用户代码的任何协程都不适合进行全局调度。
在用户协程退出或者被抢占时，意味着需要重新执行协程调度，这时需要从用户协程g切换到协程g0，协程g与协程g0的对应关系如图15-2所示。要注意的是，每个线程的内部都在完成这样的切换与调度循环。
![[Pasted image 20220315160846.png]]
协程经历g→g0→g的过程，完成了一次调度循环。和线程类似，协程切换的过程叫作协程的上下文切换。当某一个协程g执行上下文切换时需要保存当前协程的执行现场，才能够在后续切换回g协程时正常执行。
特殊的协程g0与执行用户代码的协程g有显著不同，g0作为特殊的调度协程，其执行的函数和流程相对固定（这涉及调度循环的流程，在后续小节会详细介绍），并且，为了避免栈溢出，协程g0的栈会重复使用。而每个执行用户代码的协程，可能都有不同的执行流程。每次上下文切换回去后，会继续执行之前的流程。

图15-4所示为调度循环的整个流程。从协程g0调度到协程g，经历了从schedule函数到execute函数再到gogo函数的过程。其中，schedule函数处理具体的调度策略，选择下一个要执行的协程；execute函数执行一些具体的状态转移、协程g与结构体m之间的绑定等操作；gogo函数是与操作系统有关的函数，用于完成栈的切换及CPU寄存器的恢复。
执行完毕后，切换到协程g执行。当协程g主动让渡、被抢占或退出后，又会切换到协程g0进入第二轮调度。在从协程g切换回协程g0时，mcall函数用于保存当前协程的执行现场，并切换到协程g0继续执行，mcall函数仍然是和平台有关的汇编指令。切换到协程g0后会根据切换原因的不同执行不同的函数，例如，如果是用户调用Gosched函数则主动让渡执行权，执行gosched_m函数，如果协程已经退出，则执行goexit函数，将协程g放入p的freeg队列，方便下次重用。执行完毕后，再次调用schedule函数开始新一轮的调度循环，从而形成一个完整的闭环，循环往复。
![[Pasted image 20220315161313.png]]
# 调度策略
调度的核心策略位于schedule函数中。
![[Pasted image 20220315161356.png]]
在schedule函数中，首先会检测程序是否处于垃圾回收阶段，如果是，则检测是否需要执行后台标记协程（详见第20章）。
之前介绍过，程序中不可能同时执行成千上万个协程，那些等待被调度执行的协程存储在运行队列中。Go语言调度器将运行队列分为局部运行队列与全局运行队列。局部运行队列是每个P特有的长度为256的数组，该数组模拟了一个循环队列，其中runqhead标识了循环队列的开头，runqtail标识了循环队列的末尾。每次将G放入本地队列时，都从循环队列的末尾插入，而获取时从循环队列的头部获取。
除此之外，在每个P内部还有一个特殊的runnext字段标识下一个要执行的协程。如果runnext不为空，则会直接执行当前runnext指向的协程，而不会去runq数组中寻找。
![[Pasted image 20220315161533.png]]
被所有P共享的全局运行队列存储在schedt.runq中。
![[Pasted image 20220315161550.png]]
![[Pasted image 20220315161600.png]]
一般的思路是先查找每个P局部的运行队列，当获取不到局部运行队列时，再从全局队列中获取。但是这种方法可能存在一个问题，如果只是循环往复地执行局部运行队列中的G，那么全局队列中的G可能完全不会执行。为了避免这种情况，Go语言调度器使用了一种策略：P中每执行61次调度，就需要优先从全局队列中获取一个G到当前P中，并执行下一个要执行的G。
调度协程的优先级与顺序如图15-6所示。排除从全局队列中获取这种情况，每个P在执行调度时，都会先尝试从runnext中获取下一个执行的G，如果runnext为空，则继续从当前P中的局部运行队列runq中获取需要执行的G；如果局部运行队列为空，则尝试从全局运行队列中获取需要执行的G；如果全局队列也没有找到要执行的G，则会尝试从其他的P中窃取可用的协程。到这一步，正常的程序基本都能获取到要运行的G，如果窃取不到任务，那么当前的P会解除与M的绑定，P会被放入空闲P队列中，而与P绑定的M没有任务可做，进入休眠状态。
![[Pasted image 20220315161647.png]]
## 获取本地运行队列
调度器首先查看runnext成员是否为空，如果不为空则返回对应的G，如果为空则继续从局部运行队列中寻找。当循环队列的头（runqhead）和尾（runqtail）相同时，意味着循环队列中没有任何要运行的协程。否则，意味着存在可用的协程，从循环队列头部获取一个协程返回。需要注意的是，虽然在大部分情况下只有当前G访问局部运行队列，但是可能存在其他P窃取任务造成同时访问的情况，因此，在这里访问时需要加锁。
## 获取全局运行队列
当P每执行61次调度，或者局部运行队列中不存在可用的协程时，都需要从全局运行队列中查找一批协程分配给本地运行队列
![[Pasted image 20220315161758.png]]
全局运行队列的数据结构是一根链表。由于每个P都共享了全局运行队列，因此为了保证公平，先根据P的数量平分全局运行队列中的G，同时，要转移的数量不能超过局部队列容量的一半（当前是256/2=128个），再通过循环调用runqput将全局队列中的G放入P的局部运行队列中。
细心的读者会有疑问，如果本地运行队列已经满了，那么无法从全局运行队列调用并放入怎么办？如图15-8所示，如果本地运行队列满了，那么调度器会将本地运行队列的一半放入局部运行队列。这保证了当程序中有很多协程时，每个协程都有执行的机会。
![[Pasted image 20220315161829.png]]
## 获取准备就绪的网络协程
虽然很少见，但是局部运行队列和全局运行队列都找不到可用协程的情况仍有可能发生。这时，调度器会寻找当前是否有已经准备好运行的网络协程。Go语言中的网络模型其实是对不同平台上I/O多路复用技术（epoll/kqueue/iocp）的封装，本书不会对其进行详细介绍。runtime.netpoll函数获取当前可运行的协程列表，返回第一个可运行的协程。并通过injectglist函数将其余协程放入全局运行队列等待被调度。

## 协程窃取
当局部运行队列、全局运行队列以及准备就绪的网络列表中都找不到可用协程时，需要从其他P的本地队列中窃取可用的协程执行。所有的P都存储在全局的allp []*p中，一种可以想到的简单方法是循环遍历allp，找到可用的协程，但是这种方法缺少公平性。为了既保证随机性，又保证allp数组中的每个P都能被依次遍历，Go语言采取了一种独特的方式，其代码位于findrunnable函数中。
第2层for循环表示随机遍历allp数组，找到可窃取的P就立即窃取并返回。当遍历了一次没有找到时，再遍历一次，第1层的4个循环表示这个操作会重复四次，第2层的循环操作涉及数学上的一些特性。我们用一个例子来说明，假设一共有8个P，第1步，fastrand函数选择一个随机数并对8取模，算法选择了一个0～8之间的随机数，假设为6。
第2步，找到一个比8小且与8互质的数。比8小且与8互质的数有4个：coprimes=[1，3，5，7]，代码中取coprimes[6%4]=5，这4个数中任取一个都有相同的数学特性。计算过程为
![[Pasted image 20220315162016.png]]
可以看到，这里将上一个计算的结果作为下一个计算的条件，这样的计算过程保证了一定会遍历到allp中的所有元素。找到要窃取的P之后就正式开始窃取了，其核心代码位于runqgrab函数。窃取的核心逻辑比较简单，如图15-9所示，将要窃取的P本地运行队列中Goroutine个数的一半放入自己的运行队列中。

# 调度时机
上一节介绍了调度器调度时的策略，这里还有一个重要的问题：什么时候会发生调度？可以根据调度方式的不同，将调度时机分为主动、被动和抢占调度。
## 主动调度
协程可以选择主动让渡自己的执行权利，这主要是通过用户在代码中执行runtime.Gosched函数实现的。在大多数情况下，用户并不需要执行此函数，因为Go语言编译器会在调用函数之前插入检查代码，判断该协程是否需要被抢占。但是有一些特殊的情况，例如一个密集计算，无限for循环的场景，这种场景由于没有抢占的时机，在Go 1.14版本之前是无法被抢占的。Go 1.14之后的版本对于长时间执行的协程使用了操作系统的信号机制进行强制抢占。这种方式需要进入操作系统的内核，速度比不上用户直接调度的runtime.Gosched函数。后面的小节会详细介绍强制抢占。
主动调度的原理比较简单，需要先从当前协程切换到协程g0，取消G与M之间的绑定关系，将G放入全局运行队列，并调用schedule函数开始新一轮的循环。

## 被动调度
被动调度指协程在休眠、channel通道堵塞、网络I/O堵塞、执行垃圾回收而暂停时，被动让渡自己执行权利的过程。被动调度具有重要的意义，可以保证最大化利用CPU的资源。根据被动调度的原因不同，调度器可能执行一些特殊的操作。由于被动调度仍然是协程发起的操作，因此其调度的时机相对明确。和主动调度类似的是，被动调度需要先从当前协程切换到协程g0，更新协程的状态并解绑与M的关系，重新调度。和主动调度不同的是，被动调度不会将G放入全局运行队列，因为当前G的状态不是_Grunnable而是_Gwaiting，所以，被动调度需要一个额外的唤醒机制。
如果当前协程需要被唤醒，那么会先将协程的状态从_Gwaiting转换为_Grunnable，并添加到当前P的局部运行队列中。
##  抢占调度
为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。系统监控在一个独立的M上运行，不用绑定逻辑处理器P，系统监控每隔10ms会检测是否有准备就绪的网络协程，并放置到全局队列中。和抢占调度相关的是，系统监控服务会判断当前协程是否运行时间过长，或者处于系统调用阶段，如果是，则会抢占当前G的执行。其核心逻辑位于runtime.retake函数中。

当发生系统调用时，当前正在工作的线程会陷入等待状态，等待内核完成系统调用并返回。当发生下面3种情况之一时，需要抢占调度：1、当前局部运行队列中有等待运行的G。在这种情况下，抢占调度只是为了让局部运行队列中的协程有执行的机会，因为其一般是当前P私有的。2、当前没有空闲的P和自旋的M。如果有空闲的P和自旋的M，说明当前比较空闲，那么释放当前的P也没有太大意义。3、当前系统调用的时间已经超过了10ms，这和执行时间过长一样，需要立即抢占。

系统调用时的抢占原理主要是将P的状态转化为_Pidle，这仅仅是完成了第1步。我们的目的是让M接管P的执行，主要的逻辑位于handoffp函数中，该函数需要判断是否需要找到一个新的M来接管当前的P。当发生如下条件之一时，需要启动一个M来接管：◎ 本地运行队列中有等待运行的G。◎ 需要处理一些垃圾回收的后台任务。◎ 所有其他P都在运行G，并且没有自旋的M。◎ 全局运行队列不为空。◎ 需要处理网络socket读写等事件。当这些条件都不满足时，才会将当前的P放入空闲队列中。

由于在系统调用前，M与P解除了绑定关系，因此现在exitsyscall函数希望能够重新绑定P。寻找P的过程分为三个步骤：
1、尝试能否使用之前的oldp，如果当前的P处于_Psyscall状态，则说明可以安全地绑定此P。
2、当P不可使用时，说明其已经被系统监控线程分配给了其他的M，此时加锁从全局空闲队列中寻找空闲的P。
3、如果空闲队列中没有空闲的P，则需要将当前的G放入全局运行队列，当前工作线程进入睡眠状态。当休眠被唤醒后，才能继续开始调度循环。
# 总结
运行时的协程调度器是Go语言能够并发执行成千上万个协程的核心，贯穿Go程序运行的整个生命周期。调度器的工作是在适当的时机将合适的协程分配到合适的位置，在调度过程中需要保证公平和效率。在探究Go语言调度器的过程中，两个核心的问题是何时发生调度以及调度的策略是什么。协程可以主动让渡自己的执行权利，也可以在发生锁或者通道堵塞时被动让渡自己的执行权利。除此之外，为了让每个协程都有执行的机会，并且最大化利用CPU资源，在Go语言初始化时会启动一个特殊的线程来执行系统监控服务。系统监控会判断协程是否需要执行垃圾回收或者当前协程是否运行时间过长或处于系统调用阶段，在这些情况下，调度器将借助操作系统信号机制或者抢占逻辑处理器实现抢占调度。当触发协程调度后，当前线程将切换到g0栈进入调度循环，依靠调度器获取最佳的协程继续执行。通过协调本地协程运行队列与全局协程运行队列，调度器实现了协程之间公平并高效地执行。