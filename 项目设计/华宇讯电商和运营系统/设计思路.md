# # 从76237到753毫秒,海量数据大页码MySQL查询该如何优化？
之前的sql
select * from blog_browse_history order by create_time limit 500000,10 
即使create_time有索引，依然是全表扫描

之后的sql

![[Pasted image 20240304175041.png]]
索引覆盖指的是 created_time
![[Pasted image 20240304175522.png]]

瀑布流还可以减少count(\*)
![[Pasted image 20240304175839.png]]
比如id



或者禁止随机跳页！！！！

# 热点商品如何缓存
redis缓存+本地闪电缓存（根据请求条件做一个md5）
grpc将固定请求或者数据放到 hash到一起的pod

业务部门标记热点

heavyKeeper算法

# 1000万用户电商3毫秒内抽奖100名如何实现？
![[Pasted image 20240304200200.png]]

![[Pasted image 20240304200509.png]]
![[Pasted image 20240304200711.png]]

最后的最终解决方法：
## 蓄水池算法
用户进入时先筛一遍不加入抽奖池，然后蓄水池算法，然后后台提前一段时间截止来生成名单

## 其他的方法
按每页100条数据分页，随机一个页码取数据，取出来的人全部中奖，如果人数不够，再取一次

# golang copy 函数的使用
之前用 copy 不多，本以为它是个很方便的函数，没想到在做练习题时竟还是被它坑了。是我对他期望太多了。

```swift
func copy(dst, src []Type) int
```

基本认识：

- 它只能用于切片，不能用于 map 等任何其他类型
- 它返回结果为一个 int 型值，表示 copy 的长度

## 坑位一：切片 dst 需要先初始化长度

不是你定义好类型，就能将 src 完全 copy 到 dst 的，你需要初始化长度。

- 如果 dst 长度小于 src 的长度，则 copy 部分；
- 如果大于，则全部拷贝过来，只是没占满 dst 的坑位而已；
- 相等时刚好不多不少 copy 过来。

## 坑位二：源切片中元素类型为引用类型时，拷贝的是引用

由于只 copy 切片中的元素，所以如果切片元素的类型是引用类型，那么 copy 的也将是个引用。

如下面例子，matA 和 matB 地址不一样，但 matA[0] 和 matB[0] 的地址是一样的。

```go
func wrongCopyMatrix() {
    matA := [][]int{
        {0, 1, 1, 0},
        {0, 1, 1, 1},
        {1, 1, 1, 0},
    }
    matB := make([][]int, len(matA))
    copy(matB, matA)
    fmt.Printf("%p, %p\n", matA, matA[0]) // 0xc0000c0000, 0xc0000c2000
    fmt.Printf("%p, %p\n", matB, matB[0]) // 0xc0000c0050, 0xc0000c2000
}
```

如果想 copy 多维切片中的每一个切片类型的元素，那么你需要将每个切片元素进行 **初始化** 并 **拷贝**。注意是两步：先 **初始化**，再 **拷贝**。

正确的拷贝一个多维数组：

```go
func rightCopyMatrix() {
    matA := [][]int{
        {0, 1, 1, 0},
        {0, 1, 1, 1},
        {1, 1, 1, 0},
    }
    matB := make([][]int, len(matA))
    for i := range matA {
        matB[i] = make([]int, len(matA[i])) // 注意初始化长度
        copy(matB[i], matA[i])
    }
    fmt.Printf("%p, %p\n", matA, matA[0]) // 0xc00005c050, 0xc000018560
    fmt.Printf("%p, %p\n", matB, matB[0]) // 0xc00005c0a0, 0xc0000185c0
}
```


# # 控制goroutine 的并发执行数量
### 使用有缓冲的channel，限制并发的协程数量

  

make(chan struct{}, 300) 创建缓冲区大小为 300 的 channel，在没有被接收的情况下，至多发送 300 个消息则被阻塞。

开启协程前，调用 ch <- struct{}{}，若缓存区满，则阻塞。 协程任务结束，调用 <-ch 释放缓冲区。
```go
// 通过channel来控制并发数  
  
package main  
  
import (  
 "fmt"  
 "math"  
 "runtime"  
 "time"  
)  
  
func main() {  
  
 ch := make(chan struct{}, 300)  
 maxCount := math.MaxInt64  
 for i := 0; i < maxCount; i++ {  
  ch <- struct{}{}  
  go func(i int) {  
   //fmt.Printf("i is: %d,go func num: %d\n", i, runtime.NumGoroutine())  
  
   // 模拟各种耗时较长的业务逻辑  
   //time.Sleep(10 * time.Hour)  
   time.Sleep(15 * time.Second)  
   //if i > 1000_0000 {  
   //if runtime.NumGoroutine() > 1000_0000 {  
   fmt.Println("当前协程数:", runtime.NumGoroutine())  
   //}  
  
   //读取channel数据  
   <-ch  
  
  }(i)  
 }  
}
```


# 如何设计一个rpc框架
## 代理层设计
RPC最大的特点就是**像调用本地服务(方法)一样调用服务器的服务(方法)**，实现这一点就需要我们在远程调用的时候，将其中内部的细节进行封装屏蔽，让调用者感知不到远程调用的逻辑。

看了上面的描述会不会联想到`代理模式`？ 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这个时候，访问对象`（Client）`不适合或者不能直接引用目标对象`（Service）`，**代理对象作为访问对象和目标对象之间的中介**。

所以面对客户端的请求，我们可以增加一个**代理层**，统一将内部的细节都屏蔽起来，让调用者使用起来无感知。

## 路由层的设计
当服务提供者有多个的时候，我们就会面临以下问题：**当目标服务众多的时候，客户端需要如何确定最终请求的服务提供者是谁呢？**

这里就需要引入一个叫做`路由的角色`，负责遴选出符合条件的服务提供者。客户端的请求会经过一个叫做路由层的部分，通过路由层内部的规则去选择对应的`Server`服务。

还有负载均衡
## 协议层的设计

客户端在使用RPC框架进行远程调用的时候，**还需要对数据信息进行统一的包装和组织**，最后才能将其发送到目标机器并且被目标机器接收解析，因此对于数据的各种序列化、反序列化，协议的组装我们统一可以封装在协议层中进行实现
比如http，thrift,protobuf

## 可插拔式组件设计

从客户端本地请求，到`protocol层`发送数据，整个链路中可能**还需要考虑后续的一些二次扩展设计**。例如某些自定义条件的过滤，服务分组等等，所以在设计的时候可以考虑在代理层（proxy）和路由层（router）之间加入一些链路模块。这类设计有点类似于`责任链模式`

## 注册中心层的设计

当服务提供者呈现集群的时候，客户端需要**去动态获取服务提供者的诸多信息**，那么在这个过程中就需要引入一个叫做注册中心的角色。

服务提供者将自己的地址、接口等详细信息都上报到注册中心模块，并且当服务上线、下线都会通知到注册中心。然后服务调用方只需要订阅注册中心即可。

所以对于注册中心层我们也可以统一抽取一个层面出来

## 容错层的设计

在进行远程调用的过程中，**难免会出现一些异常的情况**。市面上常见的RPC框架在处理调用异常的时候通常都会提供一些容错方面的处理手段，常见手段如下：

- **超时重试**：当调用某个provider失败的时候，会重试其他provider，可以设置重试次数；
- **快速失败**：当调用某个provider失败的时候，不会重试其他provider，快速返回异常结果；
- **无限重试**：请求失败后会自动会自动记录在失败队列中，并由一个定时线程重试；
- **异常回调**：出现异常后，回调指定方法；
- **无视失败**：出现异常后，不做任何处理。
- ……

面对这种异常的场景，我们可以尝试将这些处理手段统一抽象出来，交给`容错层`去处理

## 服务提供者的线程池设计

当请求发送到了服务提供者的时候，服务提供方需要对其进行相应的解码，然后**在本地进行核心处理**。我们如果想提升服务器的并发访问，这部分的工作需要交给专门的线程去计算处理。此时我们再对RPC框架的调用图进行修改

服务提供者还可以采用reactor的方式
通过 连接建立线程池，请求处理线程池之类的，或者网络线程池，io线程池之类的


# 目前请求进来的方式
### 管理系统
根据域名从ingress进去，然后多个同域名的ingress通过ingress的path来判断，然后打到gateway这个deployment，这个deployment是一个kong项目
### 业务系统
根据域名从ingress进去，然后多个同域名的ingress通过ingress的path来判断，然后打到gateway这个deployment，这个deployment是一个kong项目，最后通过xhost判断

# token如何存储
富Token：token本身携带了相关数据，通过密钥进行加密或者签名，例如JWT。由于携带了数据，token可以不进行持久化，但是每次都要做解密操作，属于重CPU轻存储。缺点是主动取消token会比较麻烦。
瘦Token：token就只是一串字符没有任何意义，数据关联在服务器的数据库中，属于轻CPU重存储。缺点是要占用大量的存储资源。
混合型：既然有了以上两种，当然也可以设计两者兼顾的形态，即token上带有有限的数据，同时在数据库中关联其他数据。

# 长连接与短连接的区别和应用场景！

## 一、长连接

长连接的过程：**连接->传输数据->保持连接 -> 传输数据-> ………->直到一方关闭连接（多是客户端关闭连接），则连接结束。也就是说长连接会一直保持连接的状态，直到一方主动断开连接为止。**

长连接指建立SOCKET连接后不管是否使用都保持连接，但这样安全性较差。HTTP在短链接和长连接上的选择：HTTP是无状态的 ，也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等，当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。  
HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的HTTP1.1 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。 如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了带宽。  
**实现长连接要客户端和服务端都支持长连接。**

## 二、短连接

短连接的过程：**连接->数据交换->关闭连接**

比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就断开了连接。也就是说完成了数据交换就中断了联系。  
具体过程就是浏览器客户端发起并建立TCP连接 -> 客户端发送http请求报文 -> 服务端接收到报文->服务端处理并发送Http响应报文给客户端,发送完毕之后立即调用socket.close方法->客户端接收响应报文->客户端最终会收到服务器端断开TCP连接的信号->客户端端断开TCP连接，具体就是调用close方法。  
也可以这样说：短连接是指SOCKET连接后，发送接收完数据后马上断开连接。因为连接后数据交换完成后就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。

## 三、长连接与短连接的区别

1. tcp长连接优缺点

- 优点：长连接可以省去较多的tcp建立/关闭的操作，减少浪费，节省时间，对于频繁请求资源的客户，较适用于长连接；
- 缺点：client和server如果长时间不关闭的话，会存在一个问题，随着客户的越来越多，server早晚会有扛不住的一天，这时需要采取一些策略，如关闭一些长时间不读写操作的连接，这样可以避免一些恶意连接导致server端服务受损，如果条件再允许，就可以以客户端为颗粒度，限制每个客户端的最大连接数。

1. tcp短连接优缺点

- 优点：短连接对于服务器来说较为简单，存在的连接都是有用的连接，不需要额外的控制；
- 缺点：如果客户端连接频繁，会在tcp的建立和关闭上浪费时间。

## 四、长连接与短连接的应用场景

1. 长连接应用场景  
    长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。  
    每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，每次处理时直接发送数据包就可以了，不用在去建立TCP连接。  
    例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费，使用短连接也会频繁的进行建立与关闭连接的操作，这样也很浪费时间的。

长连接还可以解决time-wait太多的问题

# 一次完整的HTTP请求过程是怎么样的呢？
dns根据域名获取ip
cdn获取静态资源
https的建立，http的建立
tcp的三次握手
ip的arp协议
mac传输
获取资源后浏览器渲染
tcp四次挥手断开连接


dns如何解析，什么是权威dns,本地dns
cdn如何确定最短路径
https过程中加密方式，http2如何进行二进制分帧，双向链路，多路复用
tcp建立的过程和断开的过程
ip层的arp协议
浏览器渲染